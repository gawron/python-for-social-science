{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##  Dimensionality Reduction (Truncated SVD and PCA) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The iris dataset is a 150x4 2D array. Each row  **represents** an iris with 4 numbers. It is a **4-dimensional representation of the data**.  \n",
    "\n",
    "Another less grandiose way of putting this is that an iris is represented by 4 of its numerical **features**.  \n",
    "In this notebook,\n",
    "we've explored training a classifier on different subsets of those  4 features, and also on\n",
    "all 4 features.  \n",
    "\n",
    "But why limit ourselves to representations constructed out of subsets of the original 4 features?\n",
    "In the assignment, you are asked to test classifiers trained on **different** representations of the data,\n",
    "for example, on a sepal area feature computed by multiplying the sepal length of each iris\n",
    "by its sepal width.  There is also a petal area representation computed by multiplying the petal length of each iris  by its petal width.  And of course, there is a representation consisting of both sepal\n",
    "area and sepal width, ostensibly a 2D representation (the classifier is trained a 150x2 array),\n",
    "but really constructed from information extracted from all 4 dimensions of the original data\n",
    "(we have been referring to Questions 4a and 4b of the assignment).  This sort of transformation of the data, using the original 4 dimensions to compute a 2-dimensional alternative representation, is called **dimensionality reduction**.  The exercise in the homework -- computing 2 area features -- is an intuitively appealing way of representing the data.  It makes sense -- and even better -- it works pretty well.  This is dimensionality reduction by clever idea.\n",
    "\n",
    "But there is a whole cottage industry devoted to finding **algorithms** for dimensionality reduction.  A dimensionality reduction algorithm is a program which, given a dataset of $n$ dimensions, and a target\n",
    "number of dimensions $m$ ($m \\lt n$), finds the **best** $m$-dimensional representation of that\n",
    "data under some very precise mathematical definition of what \"best\" means.  For\n",
    "example, viewing the data as  150 points in 4-dimensional space, consider each of the pairwise distances\n",
    "(that's 11,175 distances). We might define the best 2D representation as the one that minimizes the overall change in distances between the points.  Thus, if we're we're successful, a certain\n",
    "kind of relationship among the data points is preserved as much as possible.\n",
    "Defining Euclidean distance as what's preserved might be a good\n",
    "idea, for example, if we're using our 2D representation for\n",
    "visualization.  Points that are close in the 4D representation remain close in the \n",
    "reduced representation, so  we're getting a relatively undistorted view\n",
    "of the distance relationships between points in the data, relationships\n",
    "that can't be visualized in the original data.  Optimal distance preservation\n",
    "is the objective of a dimensionality reduction algorithm called\n",
    "**Multi-Dimensional Scaling** (MDS).\n",
    "\n",
    "But the uses of dimensionality reduction go far beyond creating\n",
    "informative visualizations. The general problem of data analysis is discovering\n",
    "meaningful relationships in your data.  This is made more difficult when there\n",
    "are many dimensions (many variables).  Thus, automatic ways of discovering redundancies\n",
    "among the variables, allowing for two or more variables to be compressed into\n",
    "one, or five variables to be compressed into three, are useful both\n",
    "cognitively and computationally. Reduction of variables may make generalizations\n",
    "easier to see or it may bring some computational analysis that was unfeasible\n",
    "suddenly within reach (for example K-Nearest Neighbor Regression,\n",
    "which we used as our example of a nonlinear regressor, may\n",
    "become computationally infeasible with high-dimensionality data,\n",
    "so doing KNN on data that has had its dimensionality reduced in some\n",
    "way is common).\n",
    "Generally reducing dimensions will lose information.\n",
    "Thus, the general goal of dimensionality reduction is to reduce as much as possible while \n",
    "achieving the best possible approximation of the original data.  The different way\n",
    "of defining and implementing these goals distinguish various\n",
    "approaches to dimensionality reduction.  We'll go through this\n",
    "more slowly below.\n",
    "\n",
    "\n",
    "One of the most famous  dimensionality reductions technique is **Principle Components Analysis** (PCA).\n",
    "This is closely related to Truncated SVD (as it's called in scikit learn), which we'll explain first,\n",
    "because it's simpler. The SVD in Truncated SVD refers to a  key concept in Linear Algebra,\n",
    "the **singular value decomposition (SVD) of a matrix**.  The SVD of a matrix $A$\n",
    "decomposes it into an exact product of three matrices computed by finding the Eigenvectors and Eigenvalues\n",
    "of $A^{T}A$.  The \"truncation\" in Truncated SVD \n",
    "refers to how the dimensionality reduction is achieved: Use only the\n",
    "top $m$ components (corresponding to the top $m$ leading eigenvalues) of the decomposition.\n",
    "So we start with an **exact decomposition** (the SVD) and then make it approximate\n",
    "by leaving out all but the $m$ most important factors (more precisely, zeroing out the others)  Truncated SVD applied to term-document matrices is called Latent Semantic Analysis or Latent Semantic Indexing (LSA or LSI).  PCA does essentially the same thing as truncated SVD but starts with centered data; if $C$ is the centered version of $A$, then  $C^{T}C$ is the covariance matrix of $A$, so the eigenvectors found are the eigenvectors of the covariance matrix; a consequence of this is that the top $m$ leading eigenvectors are the $m$ vectors that do the best job of accounting for the variance in the data.\n",
    "\n",
    "It's a rather amazing fact about the truncated SVD that it gives the \n",
    "best $m$-dimensional approximation of the original  data, \n",
    "as measured by something called the Frobenius Norm.  The rigorous idea that\n",
    "you would explore in a Linear Algebra course is that truncated SVD gives\n",
    "the best **rank** $m$ approximation.\n",
    "\n",
    "The scikit learn toolset provides implementations of a number of dimensionality reduction tools\n",
    "or tools that can be used to generate reduced output, including\n",
    "Principle Components Analysis (PCA, see `sklearn.decomposition.PCA` illustrated below ),\n",
    "Truncated SVD (see `sklearn.decomposition.TruncatedSVD` also illustrated below), \n",
    "Kernel PCA (`sklearn.decomposition.KernelPCA`, illustrated below for the RBF Kernel), \n",
    "Multidimensional Scaling (MDS, see `sklearn.manifold.MDS`),\n",
    "Non Negative Matrix Factorization (NMF, see `sklearn.decomposition.NMF`),\n",
    "Factor Analysis (see `sklearn.decomposition.FactorAnalysis`),\n",
    "and Linear Discriminant Analysis (LDA, see `sklearn.discriminant_analysis.LinearDiscriminantAnalysis`), \n",
    "well as [numerous others.](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.decomposition)\n",
    "\n",
    "The interested reader should consult [Sumithra and Surendran (2015)](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=ed2fc78cf5d7eb8233deaa9dde8f42b1e2d7f661),\n",
    "which is a survey of dimensionality reduction techniques,\n",
    "discussing TruncatedSVD, PCA and\n",
    "and at least 10 others.   Additionally, there is Uniform Manifold Approximation\n",
    "and Projection (UMAP), for which [a Python implementation](https://umap-learn.readthedocs.io/en/latest/how_umap_works.html) exists which has been applied to topic\n",
    "modelling in [BERT.](https://www.pinecone.io/learn/bertopic/)\n",
    "And of course, this list is incomplete.  As we said at the outset,\n",
    "dimensionality reduction is an **industry**.\n",
    "\n",
    "Our goal here is simply to introduce the\n",
    "idea of this kind of data analysis and to give some general motivations.  We\n",
    "will illustrate by applying PCA to the iris data set, visualizing the result,\n",
    "and apply it to the iris classification task."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Reloading"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(150, 4)\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import sklearn\n",
    "import sklearn.decomposition as dec\n",
    "from sklearn import linear_model\n",
    "from sklearn.metrics import accuracy_score, recall_score, precision_score\n",
    "import sklearn.datasets \n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.metrics.pairwise import euclidean_distances#cosine_similarity\n",
    "\n",
    "iris = sklearn.datasets.load_iris()\n",
    "X = iris.data\n",
    "y = iris.target\n",
    "print(X.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now let's reduce the data to 2 dimensions using `PCA`; we'll also use `TruncatedSVD` for comparison."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "X = iris.data\n",
    "reducer = dec.PCA(n_components=2)\n",
    "reducer_svd = dec.TruncatedSVD(n_components=2)\n",
    "X_reduced = reducer.fit_transform(X)\n",
    "X_reduced_svd = reducer_svd.fit_transform(X)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we said above that one criterion for a good dimensionality\n",
    "reduction is that it represents the data `X`  as `X_reduced`, where\n",
    "`X_reduced` has fewer dimensions,\n",
    "while approximating it as well as possible.\n",
    "Let's try to measure how good an approximation\n",
    "of `X` `X_reduced` gives. We can't directly\n",
    "compare `X` and `X_reduced` because they have different dimensionality,\n",
    "so we **untransform** `X_reduced` and use \n",
    "Frobenius Norm (`scipy.linalg.norm(X-X',ord=\"for\")`\n",
    "to quantify the difference between `X` and its untransformed\n",
    "version. In this context, Frobenius Norm becomes a \n",
    "measure of (the square root of summed) squared errors.\n",
    "\n",
    "The details of this will make more sense after we develop some other ideas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "import scipy\n",
    "\n",
    "def information_lost(X, X_reduced, transformer):\n",
    "    \"\"\"\n",
    "    Meaasure the amount of information lost by the transformer.\n",
    "    \n",
    "    Reverse the transformation and look at the difference matrix gotten\n",
    "    by subtracting X_reduced reverse-transformed from X. In the ideal\n",
    "    case of no information lost this difference should be 0.\n",
    "    \n",
    "    Compare the frobenius norm  (a kind of length\n",
    "    measure for matrices) of the difference matrix to the frobenius norm of X.\n",
    "    \"\"\"\n",
    "    return scipy.linalg.norm(X - transformer.inverse_transform(X_reduced),ord=\"fro\")\n",
    "\n",
    "def percent_information_loss(X, X_reduced, reansformer):\n",
    "    return information_lost(X, X_reduced, transformer)/scipy.linalg.norm(X,ord=\"fro\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here's our measure of information loss for PCA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3.899313318962578"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "information_lost(X, X_reduced, reducer)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And here it is for truncated SVD:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3.9408898878793743"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "information_lost(X, X_reduced_svd, reducer_svd)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Understanding the cComponents in Principle Components Analysis\n",
    "\n",
    "Now, before can understand how our PCA representations  approximate the original data,\n",
    "we have to understand what the  **Components** in Principle Components Analysis (or SVD\n",
    "reduction) are, and why they are **Principle**. Simply put, they are the $m$ (for us $m=2$)  4D **axes** (or vectors) that very naturally represent the data. \n",
    "\n",
    "Here are the components of our reduction:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 0.75110816,  0.2841749 ],\n",
       "       [ 0.38008617,  0.5467445 ],\n",
       "       [ 0.51300886, -0.70866455],\n",
       "       [ 0.16790754, -0.34367081]])"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "axes = reducer_svd.components_.T\n",
    "axes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The two columns are the 4D components.  We have named them `axes`, because that's how they're\n",
    "going to be used.  They are in fact the two leading eigenvectors of $X^TX$.\n",
    "\n",
    "Here are all four:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 0.75110816,  0.2841749 ,  0.50215472,  0.32081425],\n",
       "       [ 0.38008617,  0.5467445 , -0.67524332, -0.31725607],\n",
       "       [ 0.51300886, -0.70866455, -0.05916621, -0.48074507],\n",
       "       [ 0.16790754, -0.34367081, -0.53701625,  0.75187165]])"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "eigs = scipy.linalg.eig(X.T@X)[1]\n",
    "eigs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To find the 2D representation of iris $i$, which is row $i$ of our data $X$, we find the coordinates of row $i$ with respect to the first two eigenvectors.  For example, for the coordinate with respect to `axes[:,0]`, let $u$ be\n",
    "`axes[:,0]`, which is a unit vector, and let $\\theta$ be the angle between $X_{i}$ and $u$. Then:\n",
    "\n",
    "$$\n",
    "\\text{Coord}_{u}(X_i) = \\, \\mid\\! X_{i} \\!\\mid \\cos{\\theta} =\\,\n",
    "          \\mid\\! X_{i} \\!\\mid  \\frac{X_{i}\\cdot u}{ \\,\\mid X_{i} \\!\\mid \\cdot \\mid\\!u \\mid\\,} =\\,\n",
    "         \\mid\\! X_{i} \\!\\mid  \\frac{X_{i}\\cdot u}{\\, \\mid X_{i} \\!\\mid \\cdot \\,1} = X_{i}\\cdot u$$  \n",
    "\n",
    "\n",
    "Here we've used a standard formula for the cosine of the angle between\n",
    "two vectors, which, happily, does not require knowing the angle.\n",
    "And the result is that the coordinate of a point $X_i$ with respect to an axis, is just\n",
    "the dot product of the $X_{i}$ vector with the unit vector in the direction\n",
    "of the axis.\n",
    "\n",
    "Conveniently, that means the 1D array containing the $X_{i}$ coordinates with respect to both\n",
    "axes is just the matrix product of `axes` with $X_i$.\n",
    "\n",
    "The code to demonstrate this (matrix product in `numpy` is `@`):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[4.7 3.2 1.3 0.2]\n",
      "[5.44697714 2.09520636]\n",
      "[5.44697714 2.09520636]\n"
     ]
    }
   ],
   "source": [
    "from scipy.linalg import norm\n",
    "i = 2\n",
    "Xi = X[i,:]\n",
    "print(Xi)\n",
    "# Computing the coords two equivalent ways\n",
    "print(np.array((Xi.dot(axes[:,0]), Xi.dot(axes[:,1]))))\n",
    "print(Xi@axes)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "What we've just done is more conveniently implemented in Scikit Learn as the `.transform()` method.\n",
    "\n",
    "This method requires a 2D data array, so to apply it to a 1D array of length 4, we convert it to a \n",
    "2D (1x4) array:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[5.44697714 2.09520636]]\n"
     ]
    }
   ],
   "source": [
    "print(reducer_svd.transform(Xi[np.newaxis,:]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Call the reduced iris representation (the 2D representation of 4D data) `Xi_reduced`:\n",
    "\n",
    "```python\n",
    "Xi_reduced = Xi@axes\n",
    "```\n",
    "\n",
    "To  compute an estimate of `Xi` from `Xi_reduced`, just add the components,\n",
    "weighted by the coordinates of `Xi_reduced`.\n",
    "\n",
    "```python\n",
    "(1) Xi_unreduced = Xi_reduced[0]* axes[:,0] + Xi_reduced[1]* axes[:,1]\n",
    "```\n",
    "\n",
    "And algebraically the right-hand side is the same as \n",
    "`axes@Xi_reduced` (column-space view of matrix multiplication).\n",
    "\n",
    "We'll call this  **untransforming**."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "                                                 Xi=array([4.7, 3.2, 1.3, 0.2])\n",
      "                                         Xi_reduced=array([5.44697714, 2.09520636])\n",
      "\n",
      "Xi_reduced[0]* axes[:,0] + Xi_reduced[1]* axes[:,1]=array([4.68667405, 3.21586325, 1.30954904, 0.19452725])\n",
      "                                    axes@Xi_reduced=array([4.68667405, 3.21586325, 1.30954904, 0.19452725])\n"
     ]
    }
   ],
   "source": [
    "Xi = X[i,:]                #  The original Xi\n",
    "Xi_reduced = Xi@axes       # The 2D representation of Xi\n",
    "\n",
    "print(f\"                                                 {Xi=}\")    \n",
    "print(f\"                                         {Xi_reduced=}\")             \n",
    "        \n",
    "\n",
    "# Two equivalent ways of unreducing reduced_Xi\n",
    "print()\n",
    "print(f\"{Xi_reduced[0]* axes[:,0] + Xi_reduced[1]* axes[:,1]=}\")\n",
    "print(f\"                                    {axes@Xi_reduced=}\") "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's call our estimate of `Xi`\n",
    "\n",
    "```\n",
    "array([4.68667405, 3.21586325, 1.30954904, 0.19452725])\n",
    "```\n",
    "\n",
    "`Xi_unreduced`.  We'll now look at how good an estimate we have:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 0.01332595 -0.01586325 -0.00954904  0.00547275]\n",
      "0.023459727511097293\n"
     ]
    }
   ],
   "source": [
    "Xi_unreduced = axes@Xi_reduced\n",
    "print(Xi - Xi_unreduced)  # All differences are small\n",
    "print(np.linalg.norm((Xi - Xi_unreduced)[np.newaxis,:],ord=\"fro\"))  #Numerical measure of what's lost"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So `Xi_unreduced` is just `Xi` with a little information loss.  There wouldn't be any\n",
    "information loss if we weren't truncating the sum in the SVD representation (recall that\n",
    "`axes` has  only 2 of the 4 eigenvectors)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "What we did above in unreducing the 2D SVD representation\n",
    "is more conveniently implemented in Scikit Learn\n",
    "as the inverse transform method, which also requires\n",
    "a 2D array as its argument:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[4.68667405 3.21586325 1.30954904 0.19452725]]\n"
     ]
    }
   ],
   "source": [
    "print(reducer_svd.inverse_transform(X_reduced_svd[i:i+1,:]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To get the feel of what information loss means, let's try using all 4 eigenvectors \n",
    "on irix `Xi`.  We won't be \"reducing\" dimensionality, but we will be representing\n",
    "iris `Xi` with respect to different axes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[4.7 3.2 1.3 0.2]\n",
      "[5.44697714 2.09520636 0.01502926 0.01801333]\n",
      "[4.7 3.2 1.3 0.2]\n"
     ]
    }
   ],
   "source": [
    "print(Xi) \n",
    "# A 4D rep of Xi using all 4 eigenvectors as the axes.\n",
    "new_Xi = Xi@eigs\n",
    "print(new_Xi)\n",
    "print(eigs@new_Xi)  # new_Xi untransformed "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Zero information loss.  Of course the code we just used on 4 eigenvectors could\n",
    "also have been done with any 4 orthogonal unit vectors,\n",
    "and also with zero information loss.\n",
    "\n",
    "To demonstrate, we create four random orthogonal unit vectors."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1. 1. 1. 1.]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "-5.551115123125783e-17"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def gram_schmidt_columns(X):\n",
    "    Q, R = np.linalg.qr(X)\n",
    "    return Q\n",
    "\n",
    "def random_orthogonal_unit_vectors(n=4):\n",
    "    n_randos = np.random.randn(n**2).reshape((n,n))\n",
    "    return gram_schmidt_columns(n_randos)\n",
    "\n",
    "normed_ortho_randos = random_orthogonal_unit_vectors()\n",
    "\n",
    "# The columns are unit vectors \n",
    "print(np.linalg.norm(normed_ortho_randos,axis=0))\n",
    "# The cols are also orthogonal to one another (dot product is 0)\n",
    "normed_ortho_randos[:,0].dot(normed_ortho_randos[:,3])\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Representing `Xi` using these random axes, then untransforming with zero information loss"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[4.7 3.2 1.3 0.2]\n",
      "[-2.28536329 -3.19557593 -3.7694854  -2.10152061]\n",
      "[4.7 3.2 1.3 0.2]\n"
     ]
    }
   ],
   "source": [
    "print(Xi)\n",
    "\n",
    "new_Xi = Xi@normed_ortho_randos\n",
    "print(new_Xi)\n",
    "\n",
    "XiU = normed_ortho_randos@new_Xi\n",
    "print(XiU)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The magic of SVD eigenvectors is thus not that these 4 vectors can represent the data,\n",
    "but that just 2 of them can do so with very little information loss.\n",
    "\n",
    "Compare using the first 2 of our `normed_ortho_randos` and computing the information loss\n",
    "by reducing and unreducing:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(150, 2)\n",
      "Info loss with random orthogonal unit vectors: 77.53\n",
      "Info loss with Truncated SVD unit vectors:      3.94\n"
     ]
    }
   ],
   "source": [
    "X_reduced_rando = X@normed_ortho_randos[:,:2]\n",
    "print(X_reduced_rando.shape)\n",
    "#The inverse of normed_ortho_randos is normed_ortho_randos.T\n",
    "X_rando = X_reduced_rando[:,:2]@normed_ortho_randos[:,:2].T\n",
    "print(f\"Info loss with random orthogonal unit vectors: {np.linalg.norm(X-X_rando,ord='fro'):.2f}\")\n",
    "print(f\"Info loss with Truncated SVD unit vectors:     {information_lost(X, X_reduced_svd, reducer_svd): 5.2f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Linear Algebra teaches us that the Truncated SVD reduction \n",
    "gives the best rank 2 estimate of the original data,\n",
    "and we have just seen an example of what that means by\n",
    "seeing that the Truncated SVD axes yield a better estimate than \n",
    "two randomly chosen axes.\n",
    "\n",
    "Summing up, we reduce dimensionality, losing information; that means the reduced data yields only \n",
    "an estimate of the original data. But with Truncated SVD we reduce in such a way that we have the best\n",
    "estimate.\n",
    "\n",
    "The high-level description of how Truncated SVD does this is that it uses\n",
    "the $m$ leading eigenvectors of $X^TX$. We're not going\n",
    "to attempt here to explain how this works or indeed what eigenvectors\n",
    "are. The key takeaway is that they provide  *magic* axes:\n",
    "\n",
    "1. The reduced representation of any data item\n",
    "   `Xi` is just its coordinates with respect to the magic axes.\n",
    "2.  The reduced-dimensionality estimate of the original data is gotten\n",
    "    by unreducing: by computing the sum of the $m$ components for\n",
    "    each data item `Xi` weighted by the coordinates of `Xi`, and that estimate is the best possible\n",
    "    estimate of rank $m$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### PCA and Explaining Variance\n",
    "\n",
    "Up until now we've spoken about only one criterion a dimensionality reduction might meet,\n",
    "getting the best estimate of the original data we can in a given number of dimensions.\n",
    "\n",
    "But we'll get a much better feel for why a dimensionality reduction model\n",
    "can be useful by turning to another criterion, explaining the greatest percentage of the variance\n",
    "in a given number of dimensions.  To do that we discuss\n",
    "a slight variant of truncated SVD reduction, Principle Component Analysis (PCA).  A PCA model \n",
    "does the best job of explaining the variance in a given\n",
    "number of dimensions.  The regression notebook features an extended discussion\n",
    "of what explaining variance means, defines percentage of variance explained\n",
    "precisely and relates it to $R^2$, an important measure of the quality of a regression\n",
    "model. A point made there is that percentage of variance explained is not\n",
    "exactly the same as $R^2$, because the latter can be negative. For our\n",
    "purposes here, we're going to equate them.  This will do no\n",
    "harm because negative $R^2$ values don't arise in PCA and truncated SVD reductions.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's look at the explained variance of the truncated SVD model.  It is computed\n",
    "axis by axis.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([2.40184778, 2.03709712])"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reducer_svd.explained_variance_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Versus PCA:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'1.2.1'"
      ]
     },
     "execution_count": 49,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sklearn.__version__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([4.22824171, 0.24267075])"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reducer.explained_variance_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notice that for both models, the first axis has the greatest\n",
    "amount of explained variance, but the PCA model packs much more of its explanatory power into that \n",
    "first axis. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The percentage of explained variance is stored in the `reducer.explained_variance_ratio_` attribute:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.52875361 0.44845576]\n",
      "[0.92461872 0.05306648]\n"
     ]
    }
   ],
   "source": [
    "print(reducer_svd.explained_variance_ratio_)\n",
    "print(reducer.explained_variance_ratio_)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "More than 92% of the variance explanation is packed into that first axis\n",
    "for PCA.\n",
    "\n",
    "And the percentage of variance explained is the variance explained divided by\n",
    "the total variance.  We demonstrate this  for the PCA model, which uses centered data:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4.572957046979868"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def pca_variance(X):\n",
    "    centered = (X-X.mean(axis=0))\n",
    "    # Total variance is the sum of the variances of the four centered columns, using N-1 to compute variance\n",
    "    return centered.var(ddof=1,axis=0).sum()\n",
    "\n",
    "total_variance = pca_variance(X)\n",
    "total_variance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.92461872 0.05306648]\n",
      "[0.92461872 0.05306648]\n"
     ]
    }
   ],
   "source": [
    "print(reducer.explained_variance_ratio_)\n",
    "print(reducer.explained_variance_/total_variance)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So the total percentage of variance explained for our 2D PCA  model is:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.977685206318795"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reducer.explained_variance_ratio_.sum()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To relate this to the `R2_score` metric we discussed in the regression notebook, do:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9776852063187949"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from sklearn.metrics import r2_score\n",
    "X_unreduced = reducer.inverse_transform(X_reduced)\n",
    "# Need to specify how R2 scores of the columns will be combined\n",
    "r2_score(X,X_unreduced,multioutput=\"variance_weighted\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Comparing percentage of explained variance for PCA and\n",
    "truncated SVD, PCA wins, but not until the fourth number after the decimal point."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.977685206318795\n",
      "0.9772093692426487\n"
     ]
    }
   ],
   "source": [
    "print(reducer.explained_variance_ratio_.sum())\n",
    "print(reducer_svd.explained_variance_ratio_.sum())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So we've established that PCA does well at explaining variance,\n",
    "though we haven't said anything about how.\n",
    "\n",
    "To draw a picture coveying the main idea of PCA. We cook up a straight line `Data` \n",
    "and blur it with a bit of noise (consistent with the way the term noise is often used,\n",
    "this noise, like say, measuring errors, is normally distributed). The noisy line points are collected into a 2D array called `Data2`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [],
   "source": [
    "def line_with_noise (slope=3,intercept=4,bd=.8,step=.01,std=1):\n",
    "    \"\"\"\n",
    "    The noise is normally distributed. \n",
    "    \n",
    "    For more predictable results, ratio of `bd` to `step` shd be an integer, so\n",
    "    not for example `bd=.8`, `step=.013`.\n",
    "    \"\"\"\n",
    "    newX = np.arange(0,bd,step)\n",
    "    newY = (slope*newX + intercept)\n",
    "    Data = np.concatenate([newX[:,np.newaxis],newY[:,np.newaxis]],axis=1)\n",
    "\n",
    "    #randn(N) gives N normally distributed \"random\" pts with mean 0 and var 1\n",
    "    #randos shd have same shape as newY\n",
    "    N = int(bd/step)\n",
    "    randos = np.random.randn(N)\n",
    "    #print(N, newY.shape)\n",
    "    newY2 = newY + std * randos\n",
    "    Data2 = np.concatenate([newX[:,np.newaxis],newY2[:,np.newaxis]],axis=1)\n",
    "    return Data, Data2\n",
    "\n",
    "slope,bd = 3,.8\n",
    "Data, Data2 = line_with_noise (slope=3,intercept=1,bd=bd,std=.2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We now do a PCA dimensionality reduction to find the **one** component best\n",
    "capturing the variance of the noisy points in `Data2`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [],
   "source": [
    "#reducer_svd = dec.TruncatedSVD(n_components=1)\n",
    "\n",
    "def PCA_reduced(Data,n_components=2):\n",
    "    reducer= dec.PCA(n_components=n_components)\n",
    "    return reducer.fit_transform(Data),reducer\n",
    "\n",
    "(Data_reduced,reducer) = PCA_reduced(Data2, n_components=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We draw the noisy points in blue and the single component \n",
    "of the PCA reduction in red.  We add the original line\n",
    "as a dotted green line.  The single PCA component is almost exactly\n",
    "parallel to the original line:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x7fdb00237940>"
      ]
     },
     "execution_count": 105,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 600x400 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from sklearn import linear_model\n",
    "\n",
    "fig, ax = plt.subplots(1, 1, figsize=(6, 4))\n",
    "# scaling\n",
    "#Data,Data2 = 40*Data, 40*Data2\n",
    "ax.scatter(Data2[:, 0], Data2[:, 1], s=10, c=\"cyan\",label=\"Data+Noise\")\n",
    "#comp_vec = reducer.components_.T[:,0]\n",
    "#scaler = -2.8\n",
    "comp_vec = reducer.components_[0]\n",
    "# Get the PCA axis and the data xrange to be the same\n",
    "scaler = bd/comp_vec[0]\n",
    "comp_vec = scaler * comp_vec\n",
    "\n",
    "xhat,yhat = comp_vec[0], comp_vec[1]\n",
    "ax.plot(np.array([0,xhat]),np.array([0,yhat]),c=\"r\",label=\"PCA comp.\")\n",
    "ax.plot(Data[:,0],Data[:,1],c=\"green\",linestyle=\"dotted\",label=\"Data\")\n",
    "ax.set_title(\"1-Dimensional PCA Component\")\n",
    "ax.legend()\n",
    "#To see what linear regression does, uncomment\n",
    "#lin1 = linear_model.LinearRegression()\n",
    "#lin1.fit(Data2[:, 0:1], Data2[:, 1:2])\n",
    "#t0full, t1full = lin1.intercept_, lin1.coef_[0]\n",
    "# Plot the regression line (almost completely coincides with the original green line; look at line style)\n",
    "#X = np.arange(0,8,.1)\n",
    "#plt.plot(X, t0full + t1full * X, \"slategray\",linestyle=\"dashed\",alpha=.6,label=\"Regr\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Demonstrating the near parallelism of PCA component with the original line (with slope 3)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3.178779042533234"
      ]
     },
     "execution_count": 92,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "comp_vec = reducer.components_[0]\n",
    "comp_vec[1]/comp_vec[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The PCA axis is not exactly parallel to the original line because the noise has made\n",
    "the line reconstruction an approximation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Computing the variance explained on our own to make a point:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.5613405459296976"
      ]
     },
     "execution_count": 86,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Data2_unreduced = reducer.inverse_transform(Data_reduced)\n",
    "# Explained variance = TotalVariance - Unexplained (Error) Variance\n",
    "explained_variance = pca_variance(Data2) - pca_variance(Data2 - Data2_unreduced)\n",
    "explained_variance "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Verifying:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.56134055])"
      ]
     },
     "execution_count": 87,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reducer.explained_variance_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Why does the PCA axis point in the same direction as the original line (`Data`)?\n",
    "\n",
    "The defining feature of PCA is that it finds the axis that best explains the variance.\n",
    "Since\n",
    "\n",
    "$$\n",
    "\\begin{array}[t]{lcl}\n",
    "\\text{Explained variance} & = & \\text{TotalVariance} - \\text{Unexplained (Error) Variance}\\\\\n",
    "                          & = & \\text{Variance}(\\text{Data2}) - \\text{Variance}(\\text{Data2 - Data2_unreduced})\\\\\n",
    "\\end{array}\n",
    "$$\n",
    "\n",
    "the axis that maximizes the amount of Explained Variance has\n",
    "to minimize the Error Variance, the variance\n",
    "of the difference between `Data2` and `Data2_unreduced`.\n",
    "Because we constructed `Data2` so that all the variation is centered on\n",
    "`Data`, the axis that  minimizes the error variance has to point\n",
    "in approximately the same direction as `Data`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If we had done a linear regression, the regression line would\n",
    "have coincided or nearly coincided with `Data` (the original line).\n",
    "(You can uncomment some code in the cell with the plotting code to see this).\n",
    "\n",
    "**Question 1 (Recommended you try and answer this):**  Why is the PCA component only parallel with the original line?  Why doesn't\n",
    "it coincide with it?  This is a good question to think about\n",
    "to make sure you understand PCA.  Answer below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The job of linear regression is to predict the actual value of the regression variable ($y$ in this case).\n",
    "To minimize the error of its predictions, linear regression has to reconstruct the original line around which the noise is centered, which means finding the slope and the intercept. The job of PCA is to find the **axis** that best  accounts for the variance, and therefore any line parallel to the original line, the line around which all the variation\n",
    "is centered, will do.  By definition a PCA axis has to pass through the origin (it's a vector in $R^n$, $n=2$ in our case). \n",
    "\n",
    "PCA components are therefore axes directions, not lines; conceptually PCA represents slopes, not intercepts.\n",
    "The same could be said of truncated SVD components or, indeed, any eigenvectors. (The mathematical idea is a 1D eigenspace; in a 1D eigenspace, all the eigenvectors point in the same direction,i.e., lie on the same line going through the origin)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So how does PCA relate to truncated SVD, which we've\n",
    "been talking about until now? PCA is just truncated SVD done on centered data,\n",
    "so the ideas are the same (the inverse transform is just slightly more complicated).\n",
    "Centering the data means subtracting the mean for every variable from\n",
    "the variable values (subtracting the column means from the columns).\n",
    "When we center the data we lose the actual values of the means (and all\n",
    "hopes of finding meaningful intercepts for any lines we compute),\n",
    "but that's okay if our job is to find directions (or slopes).\n",
    "Moreover, when we compute our eigenvectors, we'll be computing\n",
    "the eigenvectors for the **covariance matrix**, \n",
    "and it is because we're  combining the special properties\n",
    "of eigenvectors with the special properties\n",
    "of the covariance matrix that the eigenvectors turn\n",
    "out to be the axes that best account for variance.\n",
    "\n",
    "To show that PCA is equivalent to centering + Truncated SVD, we do:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [],
   "source": [
    "means = X.mean(axis=0)\n",
    "X_centered = (X - means)\n",
    "reducer_svd = dec.TruncatedSVD(n_components=2)\n",
    "X_centered_svd_reduced = reducer_svd.fit_transform(X_centered)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`X_centered_svd_reduced` is not quite identical to `X_reduced` (the output of PCA) because\n",
    "of small numerical computing differences, but it is virtually 0, close enough to be called\n",
    "equal using the default numpy tolerances in `np.allclose`,  but  not quite close\n",
    "enough to be called `array_equal`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "False\n"
     ]
    }
   ],
   "source": [
    "# array1 == array2 gives an array of Booleans\n",
    "# To check array equality use np.array_equal() or np.allclose()\n",
    "print(np.allclose(X_reduced,X_centered_svd_reduced))\n",
    "print(np.array_equal(X_reduced,X_centered_svd_reduced))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x7fdb30b35e10>"
      ]
     },
     "execution_count": 119,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 600x400 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig, ax = plt.subplots(1, 1, figsize=(6, 4))\n",
    "#####  Second plot\n",
    "(Data_reduced2,reducer2) = PCA_reduced(Data2, n_components=2)\n",
    "ax.scatter(Data_reduced2[:,0],Data_reduced2[:,1],s=10,label=\"Data + Noise\",c=\"cyan\")\n",
    "tData = reducer2.transform(Data)\n",
    "ax.plot(tData[:,0],tData[:,1],label=\"Data\",c=\"g\",linestyle=\"dotted\")\n",
    "ax.set_ylim(-.5,.5)\n",
    "ax.set_title(\"Plotting on the new axes\")\n",
    "ax.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### The latent space\n",
    "\n",
    "The picture above shows what it means to plot our noisy line  points in the coordinate of system\n",
    "of the PCA components.  The blue points we're scattering are just the transformed version of the original\n",
    "noisy points\n",
    "\n",
    "```python\n",
    "Data_reduced = reducer.transform(Data2)\n",
    "```\n",
    "\n",
    "while the line we're plotting is the transformed version of the original line:\n",
    "\n",
    "```\n",
    "tData = reducer.transform(Data)\n",
    "```\n",
    "\n",
    "The fact that our transformed line is not parallel to the new x-axis is, again, a reflection\n",
    "of the fact that PCA can only approximately model the direction of the original line.\n",
    "\n",
    "In the picture above, the points are being represented in a new **space**. \n",
    "This is sometimes called the **latent space**.  The new axes are themselves variables\n",
    "which are linear combination of the old variables, but the new variables are **latent**\n",
    "or **implicit**."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Using the term rotation correctly\n",
    "\n",
    "People sometimes speak of PCA as rotating the x-axis to a new Principal Component axis.\n",
    "With data like our noisy 2D line data, that is almost exactly\n",
    "true.  On multiple runs, PCA will \n",
    "seomtimes transform our  2D noisy line data using a mathematical rotation, but it is just \n",
    "as likely to find a reflection. \n",
    "\n",
    "Here are the two forms the `components` matrix (consisting of orthogonal unit vectors) can take:\n",
    "\n",
    "$$\n",
    "\\begin{array}[t]{cc}\n",
    "\\text{Rotation} & \\text{Reflection}\\\\\n",
    "\\left\\lbrack\n",
    "\\begin{array}{ll}\n",
    "\\cos \\theta & -\\sin \\theta \\\\\n",
    "\\sin \\theta & \\cos \\theta\n",
    "\\end{array}\n",
    "\\right\\rbrack &\n",
    "\\left\\lbrack\n",
    "\\begin{array}{ll}\n",
    "\\cos 2\\theta & \\sin 2\\theta \\\\\n",
    "\\sin 2\\theta & -\\cos 2\\theta\n",
    "\\end{array}\n",
    "\\right\\rbrack\n",
    "\\end{array}\n",
    "$$\n",
    "\n",
    "\n",
    "In either case it will find about\n",
    "the same principal component, transforming the data so that it always maps the x-axis to about\n",
    "the same place -- a line with slope 3 -- either by rotating the data by an angle of $\\theta$, where\n",
    "$\\theta$ is the angle for a line with slope 3 (using a `components` matrix with the form on\n",
    "the left), or by reflecting\n",
    "it about a line whose angle is $\\theta/2$ (using a `components` matrix with the form on\n",
    "the right).  Even though only one of these two\n",
    "ways of transforming the data is technically a rotation,  it's\n",
    "correct in both cases to speak of rotating the $x$-axis by an angle of $\\theta$.\n",
    "\n",
    "This rotation view of PCA is very helpful and a great picture of what PCA does,  but it is only sometimes the case that the latent axes are actually rotations of the original axis.  If you think  about our iris data, the original data has 4 dimensions.  This means our components have this  form:\n",
    "\n",
    "```python\n",
    "[a\n",
    " b\n",
    " c\n",
    " d]\n",
    "```\n",
    "\n",
    "And although it is true that \n",
    "\n",
    "$$\n",
    "a^2 + b^2 + c^2 + d^2 = 1,\n",
    "$$\n",
    "\n",
    "there are no longer two numbers whose squares add up to one, standing in a sin/cos relation,\n",
    "so no angle $\\theta$ that we can conveniently find.  We normally talk about rotation\n",
    "in 2 and 3 dimensions.  Although mathematicians do talk about rotation in 4D\n",
    "Euclidean space, the rotation metaphor ceases to be of much use to the\n",
    "rest of us humans when the  data is 4D.  You can look  at [the Wikipedia page on 4D rotation](https://en.wikipedia.org/wiki/Rotations_in_4-dimensional_Euclidean_space) if you'd like to seem some \n",
    "pictures demonstrating why.\n",
    "\n",
    "The term rotation of axes, however, does arise meaningfully in statistical analysis of higher dimensional data , especially in factor analysis, which is related to PCA.  In factor analysis the latent axes are called **factors**.  The rotations being talked about there are happening in the latent space.  In that case, it doesn't matter what the dimensionality of the original data\n",
    "is.  For instance we might rotate the axes in the latent-space picture above\n",
    "so as to make the axes truly parallel to `Data` (if we somehow where `Data` was),\n",
    "or we might want to find axes that increase the coordinate values of the data in\n",
    "the latent space, so as to improve visualization, heighten contrasts between the axes,\n",
    "or improve interpretability.  \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, this example can be slightly modified to show the limitations of PCA. Same, picture but let's\n",
    "generate the noisy data from **two** different lines."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "bd = .8\n",
    "Data_L1, Data2_L1 = line_with_noise (slope=3,intercept=4,bd=bd,std=.2)\n",
    "Data_L2, Data2_L2 = line_with_noise (slope=6,intercept=6,bd=bd,std=.2)\n",
    "\n",
    "# Combine the two lines in to one data set.\n",
    "Data_L1_L2 = np.concatenate([Data_L1,Data_L2],axis=0)\n",
    "Data2_L1_L2 = np.concatenate([Data2_L1,Data2_L2],axis=0)\n",
    "\n",
    "(Data_reduced_L1_L2,reducer_L1_L2) = PCA_reduced(Data2_L1_L2, n_components=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x7fdb11e43af0>"
      ]
     },
     "execution_count": 37,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAgAAAAF0CAYAAABVI4GwAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8qNh9FAAAACXBIWXMAAA9hAAAPYQGoP6dpAACAEElEQVR4nO3dd3hT1RvA8W+6d9m0zBaw7A2yZS9BQURQ9lREEESWIj9AVJYigrL3dgEORJaArLI3yCy7bGhLKaXj/P64bWjatCRt0nS8n+fJU+7JHe9NQ8+5Z+qUUgohhBBCZCt2tg5ACCGEEOlPCgBCCCFENiQFACGEECIbkgKAEEIIkQ1JAUAIIYTIhqQAIIQQQmRDUgAQQgghsiEpAAghhBDZkBQAhBBCiGxICgDCJhYvXoxOp9O/HBwcKFSoED179uTGjRtJ9r906RIDBgwgICAAV1dX3NzcKFu2LJ999pnR/QHatWuHTqdjwIABZscXGhrKl19+SbVq1fDy8sLZ2Rk/Pz969erF4cOHzT6fMPTkyRPGjh3L9u3bTdr/8uXL6HQ6vv76a6Pvf/311+h0Oi5fvmy5IFPg5+dHjx49Xrhfwu+4vb09OXPmpGLFirz33nsEBgamKYavvvqKdevWpekcInuTAoCwqUWLFrF37142b95M3759WbVqFfXq1SM8PFy/z59//kmFChX4888/effdd/nzzz/1//7jjz9o3bp1kvPeuXOHP//8E4AVK1bw9OlTk2O6ePEilStXZuLEiTRs2JBVq1axadMmxo0bx+3bt6latSohISFpv/ls7MmTJ4wbN87kAkBm1r59e/bu3cuuXbtYvXo13bp1IzAwkFq1ajFo0KBUn1cKACKtHGwdgMjeypUrR7Vq1QBo2LAhMTExjB8/nnXr1tG5c2eCgoJ4++23CQgIYNu2bXh7e+uPbdSoER9++CFr165Nct6lS5cSFRVFq1atWL9+PWvWrKFTp04vjCcmJoY33niDe/fusXfvXsqVK6d/r379+nTv3p0NGzbg6OhogbsXGdWTJ09wc3OzyLny589PzZo19dvNmzdn8ODBvPvuu0yfPp1SpUrx/vvvW+RaQphDagBEhhL/h/LKlSsATJ06lfDwcGbOnGmQ+cfT6XS0a9cuSfrChQvJnz8/S5YswdXVlYULF5p0/XXr1nHixAk++eQTg8w/oZYtWxpkDrt27aJx48Z4enri5uZG7dq1Wb9+vcEx8U0e//zzD3379iV37tx4eXnRrVs3wsPDuXXrFh06dCBHjhz4+voydOhQoqKi9MfHV4FPnjyZL7/8kiJFiuDi4kK1atXYunVrkhjNiWnbtm28//775MmTh9y5c9OuXTtu3ryZ5Jw//vgjtWrVwt3dHQ8PD5o3b86RI0cM9unRowceHh5cuHCBV199FQ8PDwoXLszHH39MZGSk/l7y5s0LwLhx4/RV5KZUqZtj8+bNtGnThkKFCuHi4kKJEiV47733uHfvnsF+Y8eORafTcfjwYdq3b0/OnDkpXrw4AFFRUQwfPhwfHx/c3NyoW7cu+/fvT3Ns9vb2fP/99+TJk4cpU6bo058+fcrHH39MpUqV8Pb2JleuXNSqVYvffvvN4HidTkd4eDhLlizRf34NGjQA4O7du/Tv358yZcrg4eFBvnz5aNSoETt37kxz3CJrkQKAyFAuXLgAoM8gNm3alOQJ6kX27NnDmTNn6NatG7lz5+bNN9/kn3/+ISgo6IXHbtq0CYC2bduadK0dO3bQqFEjQkJCWLBgAatWrcLT05PXXnuNH3/8Mcn+ffr0wdvbm9WrV/PZZ5+xcuVK+vbtS6tWrahYsSK//PIL3bt355tvvmHGjBlJjv/+++/5+++/mTZtGsuXL8fOzo6WLVuyd+/eNMXk6OjIypUrmTx5Mtu3b6dLly4G+3z11Ve88847lClThp9++olly5YRFhZGvXr1OH36tMG+UVFRvP766zRu3JjffvuNXr168e233zJp0iQAfH19+fvvvwHo3bs3e/fuZe/evYwePfqFn3dsbCzR0dFJXrGxsUn2vXjxIrVq1WLWrFls2rSJ//3vf+zbt4+6desaFK7itWvXjhIlSvDzzz8ze/ZsAPr27cvXX39Nt27d+O2333jzzTdp164dDx8+fGGsL+Lq6kqTJk0ICgri+vXrAERGRvLgwQOGDh3KunXrWLVqFXXr1qVdu3YsXbpUf+zevXtxdXXl1Vdf1X9+M2fOBODBgwcAjBkzhvXr17No0SKKFStGgwYNskWTizCDEsIGFi1apAAVGBiooqKiVFhYmPrzzz9V3rx5laenp7p165ZSSikXFxdVs2ZNs87dq1cvBagzZ84opZTatm2bAtTo0aNfeGyLFi0UoJ4+fWrStWrWrKny5cunwsLC9GnR0dGqXLlyqlChQio2NtbgfgcOHGhwfNu2bRWgpk6dapBeqVIlVaVKFf12UFCQAlSBAgVURESEPj00NFTlypVLNWnSJNUx9e/f3+DakydPVoAKDg5WSil19epV5eDgkCT2sLAw5ePjozp06KBP6969uwLUTz/9ZLDvq6++qkqWLKnfvnv3rgLUmDFjEn+kRsXf/4teQUFBRo+PjY1VUVFR6sqVKwpQv/32m/69MWPGKED973//MzjmzJkzClAfffSRQfqKFSsUoLp37/7CuAH1wQcfJPv+iBEjFKD27dtn9P3o6GgVFRWlevfurSpXrmzwnru7u0kxxJ+jcePG6o033njh/iL7kBoAYVM1a9bE0dERT09PWrdujY+PDxs2bCB//vypOt/jx4/56aefqF27NqVKlQK0tvvixYuzePFio0+KqRUeHs6+ffto3749Hh4e+nR7e3u6du3K9evXOXv2rMExiTssli5dGoBWrVolSY9vBkmoXbt2uLi46Lfjn+z//fdfYmJiUhXT66+/brBdoUIF4HkzzMaNG4mOjqZbt24GT90uLi7Ur18/yVOlTqfjtddeS3JOY/djrkGDBnHgwIEkL2Od6e7cuUO/fv0oXLgwDg4OODo6UrRoUQDOnDmTZP8333zTYHvbtm0AdO7c2SC9Q4cOODhYpvuUUipJ2s8//0ydOnXw8PDQx71gwQKjMSdn9uzZVKlSBRcXF/05tm7datY5RNYnnQCFTS1dupTSpUvj4OBA/vz58fX1NXi/SJEiJlXdx/vxxx95/PgxHTp04NGjR/r0Dh06MGHCBDZv3kzz5s2TPb5IkSIABAUF6QsQyXn48CFKqSQxAxQoUACA+/fvG6TnypXLYNvJySnZdGMjF3x8fIymPXv2jMePHxMWFmZ2TLlz5zbYdnZ2BiAiIgKA27dvA1C9evUk5wSwszN8jnBzczMopMSf05yRGMkpVKiQvtNoQokLIbGxsTRr1oybN28yevRoypcvj7u7O7GxsdSsWVN/bwkl/sziP6fEn7mDg0OSzyy14gtF8b+bNWvW0KFDB9566y2GDRuGj48PDg4OzJo1y+R+LFOnTuXjjz+mX79+jB8/njx58mBvb8/o0aOlACAMSAFA2FTp0qWN/kGP17x5c2bMmEFgYKBJ/QAWLFgAwODBgxk8eLDR91MqADRv3py5c+eybt06Ro4cmeK1cubMiZ2dHcHBwUnei+9ElydPnhfGbI5bt24ZTXNyctI/MVo6pvj9f/nlF/0TdEZ38uRJjh07xuLFi+nevbs+Pb6PiTE6nc5gOz6Tv3XrFgULFtSnR0dHJylEpUZERARbtmyhePHiFCpUCIDly5fj7+/Pjz/+aBBPfAdKUyxfvpwGDRowa9Ysg/SwsLA0xyyyFmkCEBnaRx99hLu7O/379zc69l4ppR8GeObMGfbu3cubb77Jtm3bkrziO6Wl9Me7TZs2lC9fngkTJnDy5Emj+2zcuJEnT57g7u5OjRo1WLNmjcETZWxsLMuXL6dQoUIEBASk8RMwtGbNGoMn6bCwMP744w/q1auHvb29VWJq3rw5Dg4OXLx4kWrVqhl9mStxLYOlxWee8deJN2fOHJPPEd+rfsWKFQbpP/30E9HR0WmKLyYmhgEDBnD//n1GjBihT9fpdDg5ORlk/rdu3UoyCgC0ezP2+el0uiT3ffz4cYOOokKA1ACIDM7f35/Vq1fTsWNHKlWqxIABA6hcuTIAp0+fZuHChSileOONN/RP/8OHD+fll19Ocq6wsDC2bt3K8uXLk52Axd7enrVr19KsWTNq1arF+++/T8OGDXF3d+fKlSv88ssv/PHHH/pe4BMmTKBp06Y0bNiQoUOH4uTkxMyZMzl58iSrVq1K8lSZVvb29jRt2pQhQ4YQGxvLpEmTCA0NZdy4cfp9LB2Tn58fn3/+OaNGjeLSpUu0aNGCnDlzcvv2bfbv34+7u7vB9U3h6elJ0aJF+e2332jcuDG5cuUiT548+Pn5mXWe5JQqVYrixYszcuRIlFLkypWLP/74g82bN5t8jtKlS9OlSxemTZuGo6MjTZo04eTJk3z99dd4eXmZfJ7bt28TGBiIUoqwsDBOnjzJ0qVLOXbsGB999BF9+/bV79u6dWvWrFlD//79ad++PdeuXWP8+PH4+vpy/vx5g/OWL1+e7du388cff+Dr64unpyclS5akdevWjB8/njFjxlC/fn3Onj3L559/jr+/f5oLLiKLsWEHRJGNxfdAP3DggEn7X7x4UfXv31+VKFFCOTs7K1dXV1WmTBk1ZMgQFRQUpJ49e6by5cunKlWqlOw5oqOjVaFChVT58uVfeL1Hjx6p8ePHqypVqigPDw/l6OioihQporp06aJ2795tsO/OnTtVo0aNlLu7u3J1dVU1a9ZUf/zxh0n3G98D/e7duwbp3bt3V+7u7vrt+F7wkyZNUuPGjVOFChVSTk5OqnLlymrjxo1J4k9LTPGjJrZt22aQvm7dOtWwYUPl5eWlnJ2dVdGiRVX79u3Vli1bko078X0mtGXLFlW5cmXl7Oz8wl718fc/ZcoUo+9PmTIlySiA06dPq6ZNmypPT0+VM2dO9dZbb6mrV68mGX2Q3O9AKaUiIyPVxx9/rPLly6cfkbJ3715VtGhRk0cBxL/s7OyUl5eXKl++vHr33XfV3r17jR4zceJE5efnp5ydnVXp0qXVvHnzjH5+R48eVXXq1FFubm4KUPXr19fHPHToUFWwYEHl4uKiqlSpotatW6e6d++uihYt+sKYRfahU8pIN1QhRIZy+fJl/P39mTJlCkOHDrV1OEKILED6AAghhBDZkBQAhBBCiGxImgCEEEKIbEhqAIQQQohsSAoAQgghRDYkBQAhhBAiG8pwEwHFxsZy8+ZNPD09LT6JihBCCJGVqbgJpwoUKJBknY7EMlwB4ObNmxQuXNjWYQghhBCZ1rVr1/RrTCQnwxUAPD09AS14c6bbFEIIIbK70NBQChcurM9LU5LhCgDx1f5eXl5SABBCCCFSwZQmdOkEKIQQQmRDUgAQQgghsiEpAAghhBDZUIbrA2CqmJgYoqKibB2GsDFHR0fs7e1tHYYQQmQ6ma4AoJTi1q1bPHr0yNahiAwiR44c+Pj4yLwRQghhhkxXAIjP/PPly4ebm5v80c/GlFI8efKEO3fuAODr62vjiIQQIvPIVAWAmJgYfeafO3duW4cjMgBXV1cA7ty5Q758+aQ5QAghTJSpOgHGt/m7ubnZOBKRkcR/H6RPiBBCmC5TFQDiSbW/SEi+D0IIYb5MWQAQQgghsoSnT212aSkACKvr0aMHbdu2tXUYQgiRccTGwg8/gL8/XLlikxCkAJBOevTogU6nQ6fT4ejoSP78+WnatCkLFy4kNjbW5PMsXryYHDlyWC/QBNfR6XS0aNHCIP3Ro0fodDq2b99u8rm+++47Fi9ebNkAhRAis7p4ERo1ggED4NYtmDnTJmFIASAdtWjRguDgYC5fvsyGDRto2LAhgwYNonXr1kRHR6drLNu3b8fPzy/FfRwcHNi6dSvbtm1L07W8vb3TpdAihBAZWmwsfPcdlC8PO3aAu7tWCzBhgk3CkQJAOnJ2dsbHx4eCBQtSpUoVPv30U3777Tc2bNigf0KeOnUq5cuXx93dncKFC9O/f38eP34MaJl2z549CQkJ0dcmjB07FoDly5dTrVo1PD098fHxoVOnTvrx8anl7u5Oz549GTlyZIr7nThxgkaNGuHq6kru3Ll599139TFD0iaAX375hfLly+v3b9KkCeHh4fr3Fy1aROnSpXFxcaFUqVLMtFHpWAghLOb8eahfHwYPhogIrQbgxAno3x/sbJMVZ+sCwD5gWdxPW2nUqBEVK1ZkzZo1ANjZ2TF9+nROnjzJkiVL+Oeffxg+fDgAtWvXZtq0aXh5eREcHExwcDBDhw4F4NmzZ4wfP55jx46xbt06goKC6NGjR5rjGzt2LCdOnOCXX34x+v6TJ09o0aIFOXPm5MCBA/z8889s2bKFAQMGGN0/ODiYd955h169enHmzBm2b99Ou3btUEoBMG/ePEaNGsWXX37JmTNn+Oqrrxg9ejRLlixJ870IIUS6i4mBqVOhQgXYtQs8PGD2bNiyRWv/tyWVwYSEhChAhYSEJHkvIiJCnT59WkVERKT5OsOVUiR4DU/zGVPWvXt31aZNG6PvdezYUZUuXdroez/99JPKnTu3fnvRokXK29v7hdfbv3+/AlRYWJjR97dt26aKFi2a7PEJrzNy5EgVEBCgoqKi1MOHDxWgtm3bppRSau7cuSpnzpzq8ePH+mPXr1+v7Ozs1K1bt5RShvd+6NAhBajLly8bvW7hwoXVypUrDdLGjx+vatWqlWyslvxeCCGExZw5o1StWkqB9mraVKlk/vZZSkp5aGLZsgZgHzA5UdpkbFcToJTSj2Xftm0bTZs2pWDBgnh6etKtWzfu379vUEVuzJEjR2jTpg1FixbF09OTBg0aAHD16lX9Ph4eHvpXy5YtuXr1apI0Y0aMGMHdu3dZuHBhkvfOnDlDxYoVcXd316fVqVOH2NhYzp49m2T/ihUr0rhxY8qXL89bb73FvHnzePjwIQB3797l2rVr9O7d2yCuL774gosXL6b8IQohREYREwNTpkClSrB3L3h6wrx5sHEjFC1q6+j0MtVUwJZyLoX0GukZSJwzZ87g7+/PlStXePXVV+nXrx/jx48nV65c7Nq1i969e6c4y114eDjNmjWjWbNmLF++nLx583L16lWaN2/Os2fP9PsdPXpU/+99+/YxYsQIg9788dPqJpYjRw4++eQTxo0bR+vWrQ3eS1h4ScxYur29PZs3b2bPnj1s2rSJGTNmMGrUKPbt26ef0W/evHnUqFEjyXFCCJHhnT4NPXvC/v3adosWMHcuFC5s27iMyJY1AAFmplvTP//8w4kTJ3jzzTc5ePAg0dHRfPPNN9SsWZOAgABu3rxpsL+TkxMxMTEGaf/99x/37t1j4sSJ1KtXj1KlShntAFiiRAn9q2DBgjg4OCRJS87AgQOxs7Pju+++M0gvU6YMR48eNaih2L17N3Z2dgQEGP9EdTodderUYdy4cRw5cgQnJyfWrl1L/vz5KViwIJcuXTKIq0SJEvjbuq1MCCFSEh2t9eavXFnL/L29YdEi+OuvDJn5QzatAagBDMewGWAE1n/6j4yM5NatW8TExHD79m3+/vtvJkyYQOvWrenWrRsnTpwgOjqaGTNm8Nprr7F7925mz55tcA4/Pz8eP37M1q1bqVixIm5ubhQpUgQnJydmzJhBv379OHnyJOPHj7do7C4uLowbN44PPvjAIL1z586MGTOG7t27M3bsWO7evcvAgQPp2rUr+fPnT3Keffv2sXXrVpo1a0a+fPnYt28fd+/epXTp0oDW6fDDDz/Ey8uLli1bEhkZycGDB3n48CFDhgyx6D0JIYRFnDypPfUfPKhtt2oFc+ZACg9VGYK5HQx27NihWrdurXx9fRWg1q5dq3/v2bNnavjw4apcuXLKzc1N+fr6qq5du6obN25YpAODpTt7BSqllsb9tLbu3bsrQAHKwcFB5c2bVzVp0kQtXLhQxcTE6PebOnWq8vX1Va6urqp58+Zq6dKlClAPHz7U79OvXz+VO3duBagxY8YopZRauXKl8vPzU87OzqpWrVrq999/V4A6cuSI0XjM6QQYLzo6WpUpU8agE6BSSh0/flw1bNhQubi4qFy5cqm+ffsadD5M2Anw9OnTqnnz5ipv3rzK2dlZBQQEqBkzZhhcZ8WKFapSpUrKyclJ5cyZU73yyitqzZo1ycYqnQCFEDbx7JlS48cr5eiodfLLkUOppUuVio21WUjmdALUKRU3/spEGzZsYPfu3VSpUoU333yTtWvX6sd4h4SE0L59e/r27UvFihV5+PAhgwcPJjo6moPxJaMXCA0Nxdvbm5CQELy8vAzee/r0KUFBQfj7++Pi4mJO2CILk++FECLdHTumPfUfOaJtv/66NrzP19emYaWUhyZmdhNAy5Ytk+0t7u3tzebNmw3SZsyYwcsvv8zVq1cpUqSIuZcTQgghMo5nz7S2/i++0Nr9c+WCGTPgnXcgk61MavU+APGz1iU3FWxkZCSRkZH67dDQUGuHJIQQQpjvyBHo0QOOH9e233hDm8ffx8emYaWWVUcBPH36lJEjR9KpU6dkqyImTJiAt7e3/lU4g/aWFEIIkU1FRsLo0VC9upb558kDq1fDr79m2swfrFgAiIqK4u233yY2NjbFudw/+eQTQkJC9K9r165ZKyQhhBDCPAcPQrVqWpV/TAy89RacOgUdO2a6Kv/ErNIEEBUVRYcOHQgKCuKff/5JsSOCs7Mzzs7O1ghDCCGESJ3ISBg3DiZP1jL+vHm16v727W0dmcVYvAAQn/mfP3+ebdu2kTt3bktfQgghhLCe/fu1Hv6nT2vbb7+tdfTLk8e2cVmY2QWAx48fc+HCBf12UFAQR48eJVeuXBQoUID27dtz+PBh/vzzT2JiYrh16xYAuXLlwsnJyXKRCyGEEJb09CmMGQNffw2xsZA/P8yapXX2y4LMLgAcPHiQhg0b6rfjZ2eLnwnu999/B6BSpUoGx23btk2/QI0QQgiRoezdqz31xy9i1qULTJsGWbgW2+wCQIMGDUhp7iAz5xUSQgghbOfJE62H/7ffaov2+vpqE/q8/rqtI7O6bLkWgBBCCMGuXdCrF5w/r213764VBHLmtG1c6SRbrgZoCz169ECn06HT6XB0dKRYsWIMHTrUYBU9gF9//ZUGDRrg7e2Nh4cHFSpU4PPPP+fBgwcG+0VERJAzZ05y5cpFREREet6KEEJkbuHhMHgwvPKKlvkXLAh//gmLF2ebzB+kAJCuWrRoQXBwMJcuXeKLL75g5syZDB06VP/+qFGj6NixI9WrV2fDhg2cPHmSb775hmPHjrFs2TKDc/3666+UK1eOMmXKsGbNmvS+FSGEyJx27ICKFeG777Qq/169tNX8WrWydWTpTgoA6cjZ2RkfHx8KFy5Mp06d6Ny5M+vWrQNg//79fPXVV3zzzTdMmTKF2rVr4+fnR9OmTfn111/p3r27wbkWLFhAly5d6NKlCwsWLDDp+gsXLqRs2bI4Ozvj6+vLgAED9O9dvXqVNm3a4OHhgZeXFx06dOD27dv698eOHUulSpVYuHAhRYoUwcPDg/fff5+YmBgmT56Mj48P+fLl48svvzS4pk6nY9asWbRs2RJXV1f8/f35+eefU/kJCiFEKj1+DAMHQoMGcPEiFCoEGzbAggWQzFT1WV3m7wOglNaJwxbc3NI0E5SrqytRUVEArFixAg8PD/r3729034RrKVy8eJG9e/eyZs0alFIMHjyYS5cuUaxYsWSvNWvWLIYMGcLEiRNp2bIlISEh7N69G9A6brZt2xZ3d3d27NhBdHQ0/fv3p2PHjmzfvt3guhs2bODvv//m4sWLtG/fnqCgIAICAtixYwd79uyhV69eNG7cmJo1a+qPGz16NBMnTuS7775j2bJlvPPOO5QrV47SpUun+rMTQgiT/fMP9OkDQUHa9rvvwpQp8ILV8rI8qy5MnAoprWVsdN33x4+1dZht8Xr82OT76t69u2rTpo1+e9++fSp37tyqQ4cOSimlWrZsqSpUqGDSuT799FPVtm1b/XabNm3UqFGjUjymQIECye6zadMmZW9vr65evapPO3XqlALU/v37lVJKjRkzRrm5uanQ0FD9Ps2bN1d+fn4qJiZGn1ayZEk1YcIE/Tag+vXrZ3C9GjVqqPfff9+EOzWN0e+FEEKEhir1/vvP/2YXKaLUpk22jsqqUspDE5MmgHT0559/4uHhgYuLC7Vq1eKVV15hxowZgPYUrjOhNiEmJoYlS5bQpUsXfVqXLl1YsmQJMTExRo+5c+cON2/epHHjxkbfP3PmDIULFzZYiKlMmTLkyJGDM2fO6NP8/Pzw9PTUb+fPn58yZcpgZ2dnkHbnzh2D89eqVSvJdsLzCiGExW3ZAuXLaxP5ALz/vtbW37SpbePKQDJ/E4Cbm9a2Y6trm6Fhw4bMmjULR0dHChQogKOjo/69gIAAdu3aRVRUlEF6Yhs3buTGjRt07NjRID0mJoZNmzbRsmXLJMe4urqmGFdyhY/E6Ynjih/RkDgtNjY2xevF7yeEEBYXGgpDh8K8edq2vz/Mnw+NGtk2rgwo89cA6HTg7m6bl5mZmLu7OyVKlKBo0aJJMs5OnTrx+PHjZFdOfPToEaB1/nv77bc5evSowatz587Jdgb09PTEz8+PrVu3Gn2/TJkyXL161WAlxtOnTxMSEmKRdvrAwMAk26VKlUrzeYUQwsDGjVCu3PPMf8AAbfleyfyNyvw1AFlEjRo1GD58OB9//DE3btzgjTfeoECBAly4cIHZs2dTt25dOnXqxB9//MHvv/9OuXLlDI7v3r07rVq14u7du+TNmzfJ+ceOHUu/fv3Ily8fLVu2JCwsjN27dzNw4ECaNGlChQoV6Ny5M9OmTdN3Aqxfvz7VqlVL8739/PPPVKtWjbp167JixQr2799vUFhp3Lgxb7zxhsGoBCGEMNmjR/Dxx7BwobZdvLjWu79+fZuGldFl/hqALGTSpEmsXLmSffv20bx5c8qWLcuQIUOoUKEC3bt3Z+nSpbi7uxtty2/YsCGenp5J5guI1717d6ZNm8bMmTMpW7YsrVu35nzc7Fc6nY5169aRM2dOXnnlFZo0aUKxYsX48ccfLXJf48aNY/Xq1VSoUIElS5awYsUKypQpo3//4sWL3Lt3zyLXEkJkM+vXa0/9CxdqtbKDBsGxY5L5m0CnVMaavD80NBRvb29CQkLwSjRE4+nTpwQFBeHv74+Li4uNIhTm0Ol0rF27lrZt21rtGvK9ECIbevgQPvoIlizRtl96SSsE1K1r27hsLKU8NDGpARBCCJG5/P47lC2rZf46nVb9f/Rots/8zSV9AIQQQmQO9+9rVfwrVmjbJUvCokWQaKixMI0UAIRVZbAWJiFEZrV2rTaW//ZtsLPThvqNHQsvGOYskicFACGEEBnXvXvaHP6rV2vbZcpobf01atg2rixA+gAIIYTImH75RcvwV68Ge3v45BM4dMgmmf8+YFncz6xCagCEEEJkLHfuaJP4xK8cWq6c1tZvgXlJUmMEMDnB9nBgUgr77wPOAQFARq6nkBoAIYQQGYNS8OOPWg//n3/WnvpHj4aDB22W+e/DMPMnbnsfxmsFRgA1gW5xP0ekQ4ypJTUAQgghbO/WLejfX+vsB1CxovbUX7myTcM6l0z6eGB9gu3hQDuMFxbakTFrAqQAIIQQwnaUgpUr4cMP4cEDcHCAzz7T2vudnGwSUsIq/IBk9lmfaHsykNx4hHMJfmakZgFpAhBCCGEbwcHQti106aJl/pUra9X9Y8bYLPNPXIW/Bu3pPqFWLzrJwyDYOQH2TQdgMxmzWUAKAOmkR48e6HQ6/RK6+fPnp2nTpixcuNCk5XMTWrx4MTly5LBIXA0aNGDw4MHJvv/ll19Su3Zt3NzcTL5mSue8fPkyvXv3xt/fH1dXV4oXL86YMWN49uyZ+cELITInpWDpUq2H/++/g6MjjB8P+/ZpVf82klx7fzsgEFga93N0wh1io+HGAQi/Q0viCgt3T8E/n8L+7+mK1k8g8TkzwmgCKQCkoxYtWhAcHMzly5fZsGEDDRs2ZNCgQbRu3Zro6Ghbh2fUs2fPeOutt3j//fctcr7//vuP2NhY5syZw6lTp/j222+ZPXs2n376qUXOL4TI4G7cgNdeg+7dtVX8qlbVhvZ99plWELCh5Nr7z6FV23cFXlaKGiSoFVjdFua/TLPTv1IDbXTAliL1qFrqDT56eQCNlfEHvOSulZ6kAJCOnJ2d8fHxoWDBglSpUoVPP/2U3377jQ0bNrB48WL9flOnTqV8+fK4u7tTuHBh+vfvz+PHjwHYvn07PXv2JCQkRF+jMHbsWACWL19OtWrV8PT0xMfHh06dOnHnzp00xTxu3Dg++ugjypcvn6bzxGvRogWLFi2iWbNmFCtWjNdff52hQ4eyZs0ai5xfCJFBKaV16itbVlvBz8kJJkyAwECw0N+XtEquvT8AeBjxkNdXvU6RaUWIioliElptQLuCNfBw9qbJs8f6/Ru7eHOw4xqm1viQUjrj2Wxy10pPWaYAEP4snPBn4QZTzz6LeUb4s3AioyON7huboGQWFRNF+LNwnkY/NWlfS2nUqBEVK1Y0yADt7OyYPn06J0+eZMmSJfzzzz8MH66VN2vXrs20adPw8vIiODiY4OBghg4dqt3vs2eMHz+eY8eOsW7dOoKCgujRo4fFYrWWkJAQcuXKZeswhBDWcu0atGwJvXpBSAi8/DIcOQIjR2qd/tKBKRP56J/sH13R2u+Pr2BEXLq3izd7ru3heuh1Dt48qN9/We2PeTT8PsPqDEv5nAnEn9PWskwBwGOCBx4TPLj35Pm68lN2T8FjggcD/hpgsG++r/PhMcGDqyFX9Wk/HPgBjwke9P69t8G+ft/54THBgzN3z+jTFh9dbNHYS5UqxeXLl/XbgwcPpmHDhvj7+9OoUSPGjx/PTz/9BICTkxPe3t7odDp8fHzw8fHBw8MDgF69etGyZUuKFStGzZo1mT59Ohs2bNDXHmREFy9eZMaMGfTr18/WoQghLE0pmDdPe+rfuBGcnWHyZNi9W2v/Tycpjc1XSnHqzilCI0MBrQp/9OXt8Pcgyh34nolx+9np7Jj/+nwO9D1A9YLV9ce7Obphb2ef4vXjawvi+xBMTHHv9JNlCgCZmVIKnU6n3962bRtNmzalYMGCeHp60q1bN+7fv094eHiK5zly5Aht2rShaNGieHp60qBBAwCuXr2a4nG2cvPmTVq0aMFbb71Fnz59bB2OEMKSrlyB5s3h3XchLExbse/oURg2LFVP/ck9wb/oyT6liXwAGi9tTLlZ5dhwfoP+/T7+DWlWvBndS79pcFzbUm2pVqAaDnbmxx/fhyAjPPnHyzLzADz+RHvKdXN006cNqzOMwTUHJ/ll3RmqtYu7Oj4ftflB9Q/oW6VvkpLc5UGXk+zbo1IPS4bOmTNn8Pf3B+DKlSu8+uqr9OvXj/Hjx5MrVy527dpF7969iYpKvukhPDycZs2a0axZM5YvX07evHm5evUqzZs3z5A97G/evEnDhg2pVasWc+fOtXU4QghLiY2FuXO1jP7xY3BxgS+/1JbxtU/5STk5yU3Fa8oUvfrOdo9vwcaP4P456HuQczodNYB8+SvgdD2QwMfBdIzbtYh3ETZ22ZiqWDOTLFMAcHdyT5LmZO+Ek33SsaTG9nW0d8TRPmkP1OT2tZR//vmHEydO8NFHHwFw8OBBoqOj+eabb7Cz0ypo4qv/4zk5ORETE2OQ9t9//3Hv3j0mTpxI4cKF9efKiG7cuEHDhg2pWrUqixYt0t+nECKTCwqCPn3gn38ACK1bF68FCyAg9V3eknuCD0gmvR1QIOQaGy9uxNfDl4CAuFH7LjngzFqIiYQH5wnIHcAI4Mf6Y6DpZKbZO+FEynP8ZzVZpgCQGURGRnLr1i1iYmK4ffs2f//9NxMmTKB169Z069YNgOLFixMdHc2MGTN47bXX2L17N7NnzzY4j5+fH48fP2br1q1UrFgRNzc3ihQpgpOTk749/eTJk4wfP96kuO7evcvRo0cN0uL7F1y9epUHDx5w9epVYmJi9PuVKFFC3/fAnHPGxsbSoEEDihQpwtdff83du3cN3hdCZEKxsTBrFowYAeHhPHF1ZeTEiXw/YADD7OzSlKkmN1zuQPw/lIJHl8HDBxxcOKfTsef0LwzZNIRXX3qV9QGtGA5MdnCBVjMhZ3GG5vAD4goQrjn158zI0/ZahcpgQkJCFKBCQkKSvBcREaFOnz6tIiIibBBZ2nTv3l0BClAODg4qb968qkmTJmrhwoUqJibGYN+pU6cqX19f5erqqpo3b66WLl2qAPXw4UP9Pv369VO5c+dWgBozZoxSSqmVK1cqPz8/5ezsrGrVqqV+//13BagjR44kG1f9+vX1cSV8xZ8zYdwJX9u2bUvVORctWmT0vbR8FTPz90KITO/CBaXq11dKy4rV9ldeUcXPn1copX8FpuH0gQnOk/A1P/7fC+ooxqK4uFl/raPBR1XdhXXVxJ0TDc6zNEEsS5M579I0xJoRpJSHJqZTKsG4uQwgNDQUb29vQkJC8PLyMnjv6dOnBAUF4e/vj4uLi40iFBmNfC+EsIHYWJgxAz79FJ48AXd39k2aRK3330clatZbitYBzhhTls4dAUwOuQrbx0H4bUZ0+pOJ8elru8HJVdBiOiOqv29yD/t9aCMCEgtMIY7MIKU8NDGzG1///fdfXnvtNQoUKIBOp2PdunUG7yulGDt2LAUKFMDV1ZUGDRpw6tQpcy8jhBAiozp/HurXh8GD4ckTbjVsyNETJ+CDD5Jk/pD8pDfJDc/76/Et3j+xkjlXdwFau/zfjm5wdCGcX8/H4Xf16X82mcTcEQ8JNCPzh4w9Pj+9mF0ACA8Pp2LFinz//fdG3588eTJTp07l+++/58CBA/j4+NC0aVPCwsLSHKwQQggbiomBqVOhQgXYtYtIDw/6zZpFgS1bqOzvb3ThnOQyVYPOfY9vQ2wMk9EKA632f8/sNZ3pd2iuvlDQ3C0PU5pO4a9Of+Hp7Kk/TytPX/o6eaQq486o4/PTi9mdAFu2bEnLli2NvqeUYtq0aYwaNYp27doBsGTJEvLnz8/KlSt577330hatEEII2zh7Fnr2hL17AQhp0oQK8+dztWhR/S6TiZselxdX6+s79y2oBdcD4d1D4FtFWzjHvzFc2AB5yxh0zBtae6hJoZrSrBCvhgn7ZFUWHX8VFBTErVu3aNasmT7N2dmZ+vXrs2fPHkteSgghhJlMmQ43iZgYmDJFW6Vv717w9IR58/h90yaDzD9ewoVzEmasQQ+DeOuvgTT4vQ/7SNAs4JoL0MHt48939m+oFQjqjtSf01QpzfonDFm0AHDr1i0A8ufPb5CeP39+/XuJRUZGEhoaavB6kQzWb1HYmHwfhHix5DLGFAsFp09D7dowfDhERmoz+508CX36EJBg9tKEAoAHEQ9Y9986jifI1L+KjeaXA9+z4/gyakZFPG8uaPEdDLsLlXok21HQ1FkEXjTrnzBklRlYdIm+GCrRVLcJTZgwAW9vb/0rfhIbYxzjlop88uSJ5YIVmV7898HRxkuJCpFRJZcxxhcGkjwtR0drK/VVrgz794O3NyxcCBs2QJEiQKJOdE9DgOft/Z/98xlv/PgGC48s1F9/fq4SUHs4tFsJOjt91X5grhIsdcutb4tPS8e8lJbzFUlZdCKg+Ilcbt26ha+vrz79zp07SWoF4n3yyScMGTJEvx0aGppsIcDe3p4cOXLol7h1c3NLtmAhsj6lFE+ePOHOnTvkyJED+1ROMypEVpdcBrgs0fZkoPPJk1To2RPiZxJt1QrmzIGCBZO0rX8VG8P6hXU4ffMAv354kTfiJthp4NeAbZe34evh+/z6Oh00NZwS6BxJmwomYVofAmNSWs5XJGXRAoC/vz8+Pj5s3ryZypUrA9oStTt27GDSJONzQTk7O+Ps7GzyNeILGWld515kHTly5JBZBIVIgSkZoENUFCMmTaLs559DVBTkyAHffQddu4JOx7sPLjLv0FzQ2UGTCdq8+3b2eOp0KBVL9I0DEFcAeKvMW3Qo2+GF108uPbUd8+JrJRLWdmS3oX3mMLsA8PjxYy5cuKDfDgoK4ujRo+TKlYsiRYowePBgvvrqK1566SVeeuklvvrqK9zc3OjUqZNFAtbpdPj6+pIvX74UF8cR2YOjo6M8+QvxAsYyxq48rwEof/w4i3v0oMqRIwCEt32VJZ90JeKll6kbV8s678ld2DNZ67TX+Esm6+xoB8xuNZs8bnko6FVQf+7ENbPpmTGnpQYhuzG7AHDw4EEaNmyo346vvu/evTuLFy9m+PDhRERE0L9/fx4+fEiNGjXYtGkTnp6eyZ0yVezt7eUPvxAiUzFneJqlGcsYCz17huOECQybMB6PyBjCc+XCfcYMqjn9wX8b3oGIz6H+aFoB+FaFKn2hSF2IjQZ7J60K36diqq9vLdl5aJ85MtVUwEIIkVmZsnRtaqS6UHHkCBG9u9Oi4gkOFIRT/7XC//v57PPxoebB2bBrAlQfAHWGJXuKzD5tblZkTh4qqwEKIYSVJdcLP60rz6VUqEhcMLjw4AIrjq/Aw96FjzeHw4QJuEZHE/yKHRGOsZz56n38fXy0DntV+kLV97SOe3FaAesTXVsy/8xNCgBCCGFlKQ1PS20mmlKh4ueYZ3xz4wDkKg4ePgwHXrl3lrE7xlL8sRMff/1MO+Ctt1jYsys+hUtTPGdxIK5jnl3S5tXRcS9pW886pAAghBBWZo3haQaFChWr9c4HNgDf/PgGnP8LWn4PL3/AtMhIei7+h44XdDQIekZs3jzY/TAT3nqLuonO+6IOe5LxZx1SABBCCCt7UaZqbju+UoqXAJ4+hDWdIfgIfHQV7J20HQrVhhv7ISaS6vv3s6hnT0qdPs1qgLffhr+mQ968yZ5fetJnD1aZCVAIIYSh5FaeM3Xu+osPLjJw9xTePbpYW8tep2OYSw64eRDCb8PNg4wAWgLU/hinAVeYuO42e2vVouzp0zzLnx/WrIFVq1LM/OMZm89fZC0yCkAIIWxkH1qmn9geFYvLrWP45/Qnh0sOAFofW8b6dd2gQHXou1/f4W/qufVEeBWiUf7y1IprBvhh714a9epF6f/+A+BI585U/u47yJ07PW5L2JCMAhBCiEwguc6BvZY04r8rO1jZbiXvlH+HfcB6/4YQ8Jq2VC7PO/wNCWj1/MCICBg9mg+mTgWleOLjw7U5c6j8+utWvhORGUkBQAghjEiPSXtyhQXDXx/A/XPw/gn9sLvKvlW5EXyYu0/uAnBWKfAsCO/8bnC8wSiCXbugVy84f17b7tYNt2+/pWSuXFaKXmR2UgAQQohEzJ20x5TCwuVHl/nr/F8U8irE6yW1J/LGrjlxuLCB6OincP8s5CnFCODTBmM40XQSl+wc2AeUTGHpXcLDYdQomD4dlIICBWDuXG0RHyFSIAUAIUS28qLM2txJe4wVFiYqxbn75yjiXQRXR1cA1v23jo82fkSLEi30BQAXBxcWvTaPpzmLY5+zOGXirjHC2SvJOY2OIvj3X+2p/+JFLbFXL/jmG20hHyFeQAoAQohsI7kn+4SFAnMm7UmusLB+QS1O3djHxi4baVa8GQBNijWhsX9jmhZrarB/lwpdTDpnIM+H5pV6/Jjqn3wC33+v7VCoEMybBy1aJBO9EElJAUAIkS0kl7EG83xVPIAuGGds0p49j67Ats/g8W3oukmfnjNPKZxvHSXoYZA+rVy+cmzptuWFcaZUAOkK1Ni2DXr3hqC4c/ftC1OmgLf3C88tREJSABBCZAvJZazLEm0vx3CpXNBqDgqGXmfxpS345/Cnvl99AMo6ecDxFYCC8Dvgng+AT5tOxr31bK44uLAP8zoRJjc7YKmwMBgxAmbN0hKKFIH586Fp02SOECJlMhGQECJbMGfa3abAbyHXWBwbo5+0Z+6hufT8rSdzD8/V79fMLTeNW0yDrlsgbrz+CGC7ez7qO7i8cHIfY+JnDUxo3pYtVC9f/nnm368fnDwpmb9IE6kBEEJkC8am4038pA+AUnw1rzr/BR/iQN8DVCtQDdDa8Ldc2kIVnyoGu2+p8aFBHwJIOrmPuSv/xU/FGxQaSqOhQ8k3b572hp8fLFgAjRqZeCYhkicFACFEtpF4jvs8Dy5yfPdkjkU/gTe0osAInY7TngU4d+sIp+6c0hcAXin6Cnt67zF63ho8z9yTFCjimLvyX42NG6nRty9cu6YlfPABTJwIHh5mnEWI5EkBQAiRLdwJv8P2y9t5KddLdPWtDMBF4NjhuTjYOTKr9RzKO7pRA7jccjrL2y3Hy9lwKlVTxvuneeW/R4/g449h4UJtu1gx7am/QQNTzyCESaQPgBAiS7r/5L7B9rjt4+j4S0cWHV2kTyuWsxijXxnNrx1+oavOXp+p++XwS5L5m7poj7E2/IQr/6Xor7+gXDkt89fpYNAgOH5cMn9hFVIDIISwOUtOuxsTG8PL81/mcPBhLn14Cf+c/gA0LtaYXdd2UcS7iH5fnU7H5w0/Nyk+cyYHMns53YcP4aOPYMkSbfull7RCQN26L4xNiNSSAoAQIs3SkoGbMjlPcuc8f/88Mw/M5I6dPS2afa3ta2ePi4MLAAdvHtQXANqVbke70u3MjE5jzuRA8Wqk8J6BP/6A996D4GDtqf+jj2D8eHBzS02oQphMCgBCiDQxd978hEydnGc48OnTEHZd3UVA7gBeyv0SAA+fPmTavmngkpOVTSeDzo7hwNzWc8nrnpd8cePy0yrN7frG3L+vVfGvWKFtlyypPfXXrp2WswphMukDIIRIteQy8H0mHp/i5DxRTwzO2WH9+7Re1ZpJJ1awLO4aUb5VoPoAaDULYmP0+z7OV9ZimT+ksV3fmHXroGxZLfO3s4Nhw+DIEcn8RbqSGgAhRKqlpmo8IaNP0FERsLQRBB+Gj4PBVVvOtqBfA3LcPMACZy8WxO3ays4BXp2R6uubw+x2fWPu3YOBA2H1am27dGlYtAhqWGvBYSGSJzUAQohUS2vVeM7756j1z2ew63mjQVdHV4h4CDHP4HqgPr1WlT48Gngeag3Rp61P4/XNVYO4+fhTc/Avv0CZMlrmb2cHn3wChw9L5i9sRgoAQohUM6dqPCIqgm1B27gZdlOfdunhJfbu/JICh+awFG3Fu6VAl7aLYdBleOlV/TlddMb/XCVe9T7++vtA31RgU3fuQIcO8NZbcPeuNsxv3z746itwcbF1dCIb0ymllK2DSCg0NBRvb29CQkLw8vJ68QFCiHRlrHe+sbSY2BgO2tnr08eteJUNFzYwvcV0BtYYCEBYZBgDNgygQdEGdK/UHbsEmXzic+4j6RS7oBUaSLRvWjomWoxS8NNPMGCAVvVvb6899X/2GTg7p3c0IpswJw+VPgBCCJMll7EmHPL2MOIhb/70JntvH+PpkJvgoGV2rxSph++to8SoGP3xns6eLGm7xOi1Eg+jMzaXf8LahoSFEXPG7FvF7dvQvz+sWaNtV6igtfVXqZLycUKkIykACCFMYjRjvX+O0NO/UNU9H32q9AEgh0sOjt49xdOIB3DzABTRJrP5t/bH7K07Ep1OxzJS15HOlI54ae2YmCZKwapVWke/Bw/AwQFGjYJPPwUnJ2tfXQizSAFACGHSpDtnYqPh5iHIHQCuObXEGweY/c8oqhWopi8A6HQ6+ryxjCneRSB3yecnsHfiCww77qWmav5FE+xYZcy+KYKDtWV6f/9d265USXvqr1TJ2lcWIlWkE6AQWZixjnCJ05Kb4z5x96DvljSCBTXhwobnif4NaVj6TXpV6mWw75vFm0GeUtrMdgkk7rVvzpwBprL4mP0XUQqWLdN6+P/+Ozg6ajP57d8vmb/I0KQGQIgsylh7PYnSugDLEx03OSyY3X++y93751jywX+c1+kIABoXfJn/7pzkacTD59fwLMDEDr8kubax9vpWGB+2l2HH7Jvixg1tGt/1cXdWtar21F++vLWuKITFyCgAIbKg5HrMJ/HgIpz7A7yLQPw8+dGROE3KybPoCHj/JOQrC8DgZ4/5xtGNAzo7kzPWhE0LJBNToAnnyXCUgsWLtXn7Q0K09v2xY7UZ/RzkuUrYjowCECKbM9oRTsXCnVOQqzg4xi00c/4v2PgRFG/2vADg4EzPtouZk7O4Vo0fZ5qTB29jxiI3RvZNqRd/pnHtGrz7Lvz9t7b98svaHP5ly9o2LiHMJH0AhMhkTJngxmiHt/k1YHYFuPLv87RijSlQoiW81FqfNAKoU7YDFKgKdvYGp0iuh72pJvF8sp9AYGIaz5eulIL587WM/u+/tbH8kybB7t2S+YtMyeIFgOjoaD777DP8/f1xdXWlWLFifP7558TGxlr6UkJkO8l12Evo8qPLTP2lI4UXNzBIL5+vPI6ObhBy7fn58pbhRue/CKwx0CBTtmZP+jRNp2srV65A8+bQty+EhUHNmnD0KAwfLlX+ItOy+Dd30qRJzJ49myVLllC2bFkOHjxIz5498fb2ZtCgQZa+nBDZhtFx+I+uYHdxI01zlaCRfyMAvJ29+fnUzygUf4YF88DTlwCgRNMpeLaezRF7pyRt+OZOupNtKAVz58LQofD4sTZ175dfasv42tu/+HghMjCLFwD27t1LmzZtaNVKm6Hbz8+PVatWcfDgQUtfSohs5axS8ChI67BnF/df9+giJu4Yx5Vy7+gLADldczKz1UzK5i1LTbc8OMafwC03YHobfrr1pM+ogoKgTx/45x9tu04dra0/wOozCgiRLizeBFC3bl22bt3KuXNaa+GxY8fYtWsXr776qtH9IyMjCQ0NNXgJYQsZZvEYI5RSjJ9TCaYXh+Ajz98o1oTKRetTo6Bh9tyvWj/qFa2Ho70jaZEpq+vTKjYWfvhBG8r3zz/g6grTpsGOHZL5iyzF4jUAI0aMICQkhFKlSmFvb09MTAxffvkl77zzjtH9J0yYwLhx4ywdhhBmscTiMabMpmfK8a4PLrB+55dEREWwur22brxOp6NMDj8u3T1D7L3/oGB1Le4idZnYY3sqriaMungRevfWMnuAV16BBQugRAnbxiWEFVh8HoDVq1czbNgwpkyZQtmyZTl69CiDBw9m6tSpdO/ePcn+kZGRREZG6rdDQ0MpXLiwzAMg0k1Kq8yZmpEnV4B4UaHgZthNtgVtY2OekiwrUE1LfBgE04vhYOfAoxGPcHdyB+B66HVyuuTkpJN79q2Wt5bYWPj+e221vidPwM1N6+Hfvz/YyWApkXnYdB6AYcOGMXLkSN5++20Aypcvz5UrV5gwYYLRAoCzszPOsjSmsKG0Lh6T3OpzwWhNCvGGAx89vsVl9/z62fVW7JrIjP0zoPoHEF8AyOEHDb/g6wLVDKrwC3kVApJvw09rDUS2df489OoFu3Zp2w0basP9ihWzbVxCWJnFi7ZPnjzBLlGJ2d7eXoYBCptI9Zj5FNITS64AkTDzJzaGybMq4PuNL7UeXtIP47vu3xj/AtUgV4IqZp0OXhlFrhLNcbI3bQU5U4YHikRiYuDbb7WlenftAg8PmDULtmyRzF9kCxavAXjttdf48ssvKVKkCGXLluXIkSNMnTqVXr16vfhgISzI1Hb91Ax5S/i0naSgcO8s7Juu9dRv+Z2WZmcPLt6ADm4d1WbjA9aWasP8Um3oY+QaAZj2VJ9cDUS7F9xDtnb2LPTsCXv3attNmsC8eeDnZ9OwhEhPFu8DEBYWxujRo1m7di137tyhQIECvPPOO/zvf//DyYT1sGUtAJFaaZ133tQqdIOCxZP7tL3yL7nzlmFBnrilb28ehHnVwdkbht9/PpvevbPgnu/5UrpxlgInSVoAUZhWgFmG9uSf2FK0HvwigZgYmDoVRo+GyEjw9IRvvtGG+yVauVCIzMicPFQWAxJZQuKn/eRWnktrpvhPZBiNnT2fJ6zpDCdW0vuV/9G34TjOAcVjY/h183AuFanLuoDWENeO35VEzQJx4gslqS3AWKITY7Zw+rTW1r8vrkGoeXNtkp8iRWwblxAWJIsBiWzFWBW4scwfzJ/KNj5TLhr9lI8W1uHorWMw7A645tJ28GsIt47y1DXX8855dvbUbv6NwfHxtQq+JN/UkLBzn7GCAhjvmCiz9r1AdDR8/TWMGQPPnoGXl9b237OnPPWLbE0KACJTSpixJtcJL3EtgKmZ4n/3/mPhkYUEOnuz85VRWqKDC7mjIohVMXBjP5RooaVX7g1V+jAwmXMl7rFv6ux65nZMzPaz9iXn5Ekto4+fifTVV2HOHChUyLZxCZEBSBOAyHQSV/d3AZYb2S8w7mdKmeLjZ4/ZfXU3ZfOV1Q+z23RxE82XNwfvojD48vOdbx7iT88C/Ovpm+Rp2xqr2iW+T2tdJ0uKioLJk2HcOO3fOXLAd99B167y1C+yNGkCEFmWser+5SRtX09ctR7vWcwzg6F1HX7uwIYLG5jWfBqDamqLVdUpXIf6lXuzw68BqFjQxQ1rLVCVB6Tf07Y81afS8ePQowcciZsy+bXXYPZsKFDApmEJkdFIAUBkKslV9zcFPiD5zPJBxANeX/U6J+6c4M7QOxx1cOYc4F+0Pn73zmCfYN17dyd3Jr0+32jHuvgqeFMX1Emr9LpOlvDsGUyYAF98obX758wJM2ZAp07y1C+EEVIAEJlKSm3j8Znlf/f+Y+zJ1fh4+NCvWj8Acrrk5OLDi4RGhtLr5gFWFqmrHVj7Y4bXHcGAROeTjnWZzJEjWlv/sWPadtu22qQ+Pj42DUuIjEwmuRYvZI1V8lJ7zviMWS86kk5XdlLiyX190pHgI4zbMY65h+bq03Q6HSvbreTXDy+ysnCd58fbOTA5mTgmofUjWBr3U9rfM6Bnz+B//4OXX9Yy/9y5YdUqWLNGMn8hXkAKACJF1phiNi3nVEoZZMwVlzVh5eJX2HBhg36fhv4NeafcO/Sv3t/g2Ib+DQnPWcxodXByTQvZcjnczOLQIahWDcaP16r827eHU6fg7belyl8IE0gTgEiWNaaYTc059wH7wm6y8ree3Ll/nosfXqSGTkcN4GSh2gTfP8fjZ4/1+/t4+LDyzZVGz5XWef9FBhAZCZ9/rq3WFxMDefPCDz/AW2/ZOjIhMhUpAIhkpXWVPHPPGf/T5f45gv5bh18OPw6V7aAVGNzywNVdEPWEU3dPUS5fOQDGNhjLxCYT0Zn4xCdt+5nc/v1aW//p09p2x45aR7+8eW0blxCZkBQARLKs8bSc5NjYGLh9jL9yl6Rb3Lr3XNwEW0ZQvVgTDpTtoKXZO8EbyyFXCcLyltEf7uroanYMMrwuE3r6VJvJ7+uvITYW8uXTOvm1a2fryITItKQPgEhWkg53pO5pOWGHvyTnnP8yzK3K6is7nqcVawIl25Cv9JuGJyr9BuQvzwVd2r+20rafiezdC5UraxP7xMZqw/pOn5bMX4g0khoAkaK0Pi3rZ7N7GASbhlDg8S1u9N6rP+fPPpXZ8uACEY9vPT8oTyl4ex3VMD6nv7TXZxMREdqqfVOnglJar/7Zs6FNG1tHJkSWIAUA8ULmTkZz8cFFNlzYQGzuACYXb6YluuaEs79zU8XyZ9hNWnsWoAbwWrOvOd16DnUSTMQTryUQgbTXZ0u7d2sr952L6x3SrZu2gE+uXLaNS4gsRJoAsilLje1XSvHfvf+Ijo3Wp604sYKBGway4siC5zu65IDX5kHvQO6559Mn53DJQW07+2SbGmQsfjbz5Al89BHUq6dl/gUKwJ9/wpIlkvkLYWFSA5ANJV5kZjhaRmuO+NX4xs4qz6W7pwjsHQiFanAOKFCsKU2u7qRSkVfYn/Cgyr0AKG3kfCk1Nch0uNnEv/9qT/0XL2rbPXtq1f85ctg0LCGyKikAZDOpHdt/7v45xu0YR0RUBC91XPP8HLkDcHh4kfEPLrC+UNwZCtdieNfNTEKrYjK1Cl8y+mzq8WP45BP4/nttu1AhmDcPWrSwbVxCZHFSAMhmTBnbfzXkKlsvbaVM3jLUiMvUneydWHliJfY6e2KePQYnD23nV38g2jUn6x1cDM4XX6iQIXciRdu2Qe/eEBSkbffpow318/a2bVxCZAPSByCbMdqDPuQaLyml3/xmzzf0+r0XS44t0af55fBjcpPJDOu6Geydnx/r6QuJMv948YUNGXInkggLg/79oVEjLfMvUgQ2btSe/CXzFyJdSAEgizHWuS/ZcfgqFn4oA9OKkPvBBf3+TYs3pXbh2pRJMOEOwLA6w2jr3xDsHU2KRYbrCaO2bIHy5bWJfAD69YMTJ6BZM9vGJUQ2I00AGUx857oXVZcb289Y5z7i0+6egcBvqWTnwJFWM7VqeZ0d37rn5fj9c5y4c4KXcr/EPuBhQGumBrQ2ev3kptJVRtLkiV8YCA2FYcNgbtwqjX5+MH8+NG5s07CEyK50SiWo+80AQkND8fb2JiQkBC8vL1uHk65M7Z1vbL92aCvrAfD4NlzeDvnLQ/xTfPBhmFsVnL3YNfw+dey0st/FBxfJ554PT2dPs0YHGCuAmFp4EdnQxo3Qty9cu6Ztf/ABTJwIHh62jUuILMacPFQKABnEPhJk4AkEYpiZGt0v4iFjXHMyLn57bVc4vhzqjYJGX2hpsTHwz2dQpC6LSjSnh51h5Y+p1xfCLCEh8PHHsCBuTohixbR/N2hg07CEyKrMyUOlCSCDMGWVvIDE+0U/hXkvw52TPBl2R1sxD8C/Mdw5CR4+z/e1s4cmEwDj4/CtsfKfyOb++gvefRdu3NC2P/wQvvoK3N1tG5cQVpZZakOlAJBBJNdhbjPQDeDOKTg8j/LO3tAw7lnfwUXryIei4M1DDC/RXKvCr9QDKvUwq23eGiv/iWzq4UNtNr8lcaNISpSAhQu12f2EyOIsMdFaepEmgAxE/8V5+giu7KSdT0XWeBfR3ry4GZY3A6/CdBl8heU6nZZ+6xgDvQoyPe7pPy1t84m/uCOQqXeFmf74A957D4KDQaeDwYPhiy/Azc3WkQlhdRmhKVWaACzM2tU5T6Of4uLgop805701nTl2/i9cmk2FWh9pOxWpA9XeB78GNEExAJ0Wk0/FF06ba+oMezJpj0i1Bw9g0CBYvlzbDgiARYugdm3bxiVEOspsTalSAHgBa1bnPIx4SIsVLTh15xT3ht/DxcGFGkDnog2IeHCBAg4JJtxxdINWMwEohfWmzZXpeIXZ1q3TxvLfvg12dlqnv3HjwNXV1pEJYTGmPAhmtqZUmQgoBcnNm5+aFfRO3TnFp1s/Zca+Gfq0HC45uBZyjfCocA7dPKRP/7j2x5wdcJYp1fsnu0qeEDZ37x506gRvvKFl/qVLw549MHmyZP7C4iy1gmlqjECr2u8W93NEMvsZTLSW4NiSTx8x4fQvNos/OVIDkEjCUl5qqnP2ASejIoi4toe3fSqSJ65t/sSdE0zYNYFKPpUYWGMgADqdjh/b/4hfDj8KexfWn8NO97xcJtXyIkP69VdtKt87d7Sn/uHDYcwYcDE+LbQQaZHeHesS5gOQ/AJqLyvFw6cPyeX6fKnqwvu/p+a5P6lepS+dy7xJDaBv+B3m//wWfBoOjm4ZpmOgFAASSPwl65LMfomrc2JiY7C3s39+/LKmcG03G9ouYX3FbgA09GtI94rdaeTfyODYekVf3DNaquVFhnHnDgwYAD//rG2XLau19Vevbtu4RJaVmhVM09JvK3E+0Arg3lm4fRzylNImWAN2Pwyi4cyy2NvZEzoyFF1cx+xTd04ReHEjjQtUo0aZN9kHzPcuAkXrw9MQcHQzaQXW9CBNAHGMfcmWoy1ik1DCKvibYTdpuKQhRacVZa+KfX58kXrgWZC/op/qq3vye+RncdvFdIsrEAiRqSgFP/2kZfg//wz29jBqFBw6JJl/NmKLavgXzZGSWHLV9cZiV0oRHRut397y9BGT/xoIP7XXvvPAeoDAb+GXDnD6Z/2+VT18iIiOIPxZOFuePtKndyrfiQWvL+Cdcu88j9PBBXps1xZPe0H86Slb1wCYUt3fFPgA2Hb3NEFn1lAhZzEo3wmAvG55OXDjAOFR4Wy7c0pfMqTBWGj8Feh0Gbb3pxAmu31bq+5fs0bbLl9ee+qvWtW2cYl0Zavx7eZ0rDNaWxAbw6k7J1kfcgUCXgOdjuGAx47xfL33awbVGMTnDT8H4Iq9Mxz4Xjvw6UOIq9ov51OJk4Vrg4eWgY8A/nJ0hQ8vorwK0czeSf951Ctaz6BmNyN3DLRKDcCNGzfo0qULuXPnxs3NjUqVKnHo0KEXH5iOEpcSNyV8MyYKrgfCs8f6KiSvy9uZu200C44s0O/maO/I6var+e+D/2iUr9zz4x2ctTHQZIxfshCpohSsWgVlymiZv4OD1s5/8KBk/tmMJTtEmyu5jnXGHqzWBW2DjUPg5OrniTHPWD+nEqxuo2XqaLHfsnckNDKUg48u62sGyjm6QoPPodVssHu+6un8av0I7LWbpdXfJxB4I+4c5CwG9k76cxr7PMyJP71ZvAbg4cOH1KlTh4YNG7Jhwwby5cvHxYsXyZEjh6UvlWpJvsxKsVynoytaFRHzX4ZbR3nznT+oEdAagCbFmvBWmbdoXry5wXkeBrTmEVohwtgqeRnhlyyE2YKD4f334bfftO1KlbSn/kqVbBmVSEdp7RD9onOautpp+agndH90mWp2jjzN/RIBQJWYKKotqMXlR5c5P/A8OV1zAhByPVCrrq/YDcq9rZ3M0RXyltWGUj8N0T/Vl6rYnd4l27AgR1E2xF13ODC8/uhk/47H/1yWTNzJfR4ZtTO3xQsAkyZNonDhwixatEif5ufnZ+nLmM3ol/lhEGwYoK2e9+5BfXX/yALVORxyldZP7umPD8gdwE9v/aTfTq46zJxfcmaZL1pkI0ppk/kMGqRN6evoCKNHw8iR2r9FtpDaDtHxTF2ufFKCfV9SiqOH5rDoYRD7XxkFztosdq8Efse//3xK94rdWdx2sXawvSPXQq9xP+I+fzy6jM41JwFAp6L1OFjrYw4UrqO/TldgWf+TSWJ08/RlQYI2eeLiC+TFf8dTU62fITtzKwsrXbq0Gjx4sGrfvr3KmzevqlSpkpo7d67Jx4eEhChAhYSEWCym4Uop7p1V7JmqOPeX6qKUQilFxCPFODvFWBQh11Rg3P6hT0NVTGxMsucLjD8+0Ssw2SOSiSnBa7i5NyWEpV2/rlTr1kppxQClqlRR6vhxW0dlM4FKqaXKvP/XWUFyf9+6Jtoekczxif+2DYl6qn66d04RHfk8/cxaxfyaqvTfHxns6zIln/b3OPjI8/TjK5XHBG/Va10vg+tsD9quetw6poh6muTvaOLfXeKYRsS9b+w+l5r4ORk7Z0ZgTh5q8QKAs7OzcnZ2Vp988ok6fPiwmj17tnJxcVFLliwxuv/Tp09VSEiI/nXt2jWLFgD0X+Yd47Uv1k9vGX6Zjy5V3DyshsVEm3zOtH5xLFGAEMJiYmOVWrRIKW9vLeN3clLqyy+VevbM1pFZhSkZe2YqoKe1oJL4+JT+vqV0rUsPLqlPD81XnP7V8Fh9pn40Qaa+QktbVN9w340fK/76UHH//PO02Bijf1vN/TuaOHZL/B3OiIVEmxYAHB0dVa1atQzSBg4cqGrWrGl0/zFjxii0ResMXpYqAOi/zNcCFSteVRycY9KXOSVp/eKltQAhhMVcvapUy5bPn/qrV1fq5ElbR2U1pmTsliqgp0fmkNaCirHjk9x/TJTiyX2D+xj410BVb2E9derOKX3a8mPLtUx9cQPD4+dWV45fuikubn6eFnJNceoXxa3jRj9rUz57S/wdzahP8Wlh0wJAkSJFVO/evQ3SZs6cqQoUKGB0/3SrAVAv/kKZw9Qvjkn/wSwUkxAmi41Vav58pby8tIzf2VmpSZOUioqydWRWY+r/O2tkLNaoQUjr35Ekx1/bqzi6RP0ZevN5/Kd/VYyzV0UWNzA4ttrcaoqxqHVn1unTDt88rGotb6n453+G540MU3tjY5N8JombFJJLT+5va2YqqKUncwoAFu8EWKdOHc6ePWuQdu7cOYoWLWp0f2dnZ5ydnY2+ZwnxQzAs3TvflA5/Kc1gJSMGhM1cvQp9+8KmuMGvNWvCwoXaXP5ZmKk92dM6bjs1M9elhqn3E6tiiVWxONhpf+5P3D7Bd/u+46ZLDmj29fMdNwyEmwfZ3HEd00q1oR3wp3t+vlAxuITdNLjGp3U/JTImkuoFqz/v8OdbmT2d/0q6rLiTBzXRRkol/pvpm3hftCXIP+DFHaQt9bc9Q3bOSy+WLn3s379fOTg4qC+//FKdP39erVixQrm5uanly5ebdLw1OgEqZZtS3oueJLJayVNkcLGxSs2erZSHh/bU7+Ki1NdfKxVtev+XzMycJ8a0VA1bs4kv4d8Mg/uJfKy4ukdxcYvB/bRd3VY5jXdSv//3uz5t55WdirGoAtP8DWP860PF0iZq+sXN+n2fRj1VN0JvJNspOrmaDnP+tlm6D0N2Z9MmAKWU+uOPP1S5cuWUs7OzKlWqlM1HAdiKVPWLDCMoSKnGjZW+rb9OHaXOnrV1VFZlLGMwJ2NPrz5CptLHfnSJ4o/3VJdre5+nXf5XMRaV47tiBse8+eObirGo7wK/06fdDb+rPt/+uVpxfEWaCjry9y1jMicP1SmllG3rIAyFhobi7e1NSEgIXl5etg4nzZJUh6FVcQmRLmJjYfZsbbW+8HBtmd6vvoKBA7X5/LOolKatTY/5N5L7f5/ctR9EPODSw0sU8CxAAc8CgLaozFs/v4W9nT3z3z9Bzfidf3oTzqyBFtMJjFtZNDD0OhMX1qFc7gA2ddmkX5jm0sNL2OvsKehVUN8EkFhqP49laDOpJraUpGuoiPRjTh4qBYB0IBP+CJu4eBH69IHt27XtevW0tv4SJWwalrXtg+eZZQKBpP3/nzn/lxPvOwKY/OQ+HFsCkWEMbzBGXyhp8GM7dvy3lo9bzuDrlwcA8HvINdpMK4K9nQMLRj2lh11cge3EKrh3Bl5qxdJCNWyW2VrzcxapZ04emq0XA0ov2bqTiUh/sbHwww/a7H1PnoCbG0yapC3oY2fe8h+ZsfBqqWlrE0upViHkaQg3w25SOu/zjpTbdk1k1clVfPjyh1Clt3ZsVDhs+hjsHJn8yme0s7NnDbAjZzHw8OUbFUt8vcxkzwLQdTMxOfzYHPdED0D5d/T/NHetEUv+Pq3VwVqkHykACJGVnD8PvXvDzp3adoMGsGABFCtm9qlstfpbWllj9TV9z/4bB7SFwnwrM7lIXdoBviFXKTqtKI52jjz97Cl2Oq2QdSf8DsdvH+fMvTM4xZ/Is6A2R713UYh5xgY7V+28Tafoe+TrP3M7eyjWBIAV8HytkjjmZrbW+H1m1DnuhWmsshqgECKdxcTAt99CxYpa5u/uDjNnwtatqcr8bbn6W1qlZvW1HVFPmP30kf7+Qp6G8NbPb1FrQS1iVezzWoUTK+HvD+E/bZGkc0ABzwLY2zng4uLNxgTrh/So1IP1ndbzYY0Pnxc+7OzhzVXQZKK2SE28hE/4yWiKVr2+NO6nOX2JrPn7rIFWOJHMP/ORGgAhMruzZ6FXL9izR9tu3Bjmz4c0LMJlrWr09GLsyTQ6Npotl7Zw+dFl3q36rv5JvdbWUQTu+gpqD4OmkxkOfOnkztoza4lRMdx6fIuAuI55FKoBIW9A/vIQd+5Rdg7EjAwhzNGNV3n+ZF0hfwUq5K8AQBGMV5e3BMaZeE/x95Gazz+z/z6FdUgBQIjMKv6pf/RoePoUPD3h66+1SX5MeKJMiTWq0a0pMjoSJ3snfe/39efWs+LECuoWqUuN6v31+7Ve2ZoYFcPrJV+ngGcB9gGB7vm0Nx8HA3GT9tg5MKf1HHK75cbb2ZsCxGXg5d7WLzM7Iu6ck0FbajbBtrFJf5KrLjdWMFBG0szNqBO292e236dIH1IAECIzOnMGevaEfXGVuM2awbx5UKSIRU6fETt43Qm/w8k7J/Fy9qJagWqANstdse+KcTXkKjeG3MA3bnnX8w/Os+rkKqJjo+kfVwBwsHOgSbEmONo7EhkdCcQ9GVfuqa0f75JDf61zQO8qvQ2ubywDN3ddeGNP8MkVDNLStm6svT+j/T6F7UkBQIjMJDoavvkGxoyByEjw8tJqAXr2TPNTf2Lp2cFLKaV/egcYv2M8Fx9eZErTKeR1zwvAiuMrGLJpCB3LdmR1+9UA+mp8hWLWoyBaefpSA2jo15ApTadQxbeKwXX+7vK3wXYA6NedT5JuROIM3FJP1sYKBqmt7k+uvd+Ude5F9iIFACFSkKGGwZ08qbX1HzgAwKOWLckxdy4UKgSYHqs592TJIazXQ68T9DCIGN8qXHNyJwC4cuonRmwZQZ3CdVjebrl+3/lH5nM15CpFq/XjVfe81ABeyv0SpfKUwtfD1+C8TTpvYIFbHsa75WE8cW3wPhWp6FPxhTGltaYjI9aUpNTeL531hAHrTkpovqw0FbDI3DLMmvDPnin1xRdKOTkpBeqht7fqtnixIm6FNXNiTY97On3ntPpixxdqzsE5BumFpxbWlou9tld//ban1yjGomrMq2Gwb/1dkxX/fqV4eDnFODPKinAZaT56maI3e7P5WgBpIQUAkRFkmD+ix44pVaWKfg7/31u3Vr43bhjENN/EWNNyT7GxsSo4LFidv3/eIL3rmq4qYEaAWnTjgD4D/PX0r4qxqJrzaxrsW21JY8V3xRSXtj6/fvg9NefKLnUj9Eaq4rTmwjuZWVZc516YxqbLAQuRFdh82FRUFEyYAF98of07Z052TZ/O6507J2nrP5DMKRLHauo9rT+3nlN3T9G+THuK5dTmEFhzZg3tf25PzUI1mdZ7r74JIehREOfun6Png4sQ1zGvd96y9KjUgwr5KhhcZ2DXzXRP3E/BLTeuRepwDdgad05zPnvp3W6cTNAjTCEFACGMsGnGcvQo9OgBx45p223bwsyZOPr6Gt29OjDHSHrCWJVS5H/6EOydwcldS7x1FP75jBUuOeiaoP194u6J7Lq6i6LeRfUFAL8cfujQERQTZTD/e9NGX0JsDCRob1+QpySBbRYlyXRKJtNJcTOGi8p0MbqX8c8+I7bBZxQyBbl4EZkJUIg4+9CGde0jdbPJpeY6Ce1/9oxjY8YQW726lvnnzg2rVsGaNeDrm2xMvROmRzyE/9bx2snV1EhwrZrLm9N8cm5eP7/++cGxMXB+PceCthqcs3nx5nQu31k/pA6gkk8l/v3sKbffPWiw7+air4B/Q3DNZZAe/xT/os808fS2AMtJuppcws8+8ec3idTPkCdEdiY1AEKQ/Dzplq5GTe460w8dokHPnlQ4cQKAE2++SfkffoD8+fX7RkRFMMnRVR/Tsf3fczZoK1uqf8CkYk1oB/z94AJjf3yDQ54FGFHu7efXipvspvHjW3wad3zB3AFcaD0H/xz+BiMDPnvlsyRx29vZE4TpywcHpHCvCT/TcxgfS98U+ICkn31y55SnXSFSwfpdEswjnQBFerNmh7+EvcONXcfp6VN15NNPVZS9vVKg9hfLqeosGKm4f15//ZO3T6pck3KpAt8UMDh3p187KcaiJu+arE+7F35PvTzvZdXk546K2BiDznY8e2L0nkwdGZDc59RVJe1wZupnas5nn2E6ZgqRgUknQCHMkF7Lx76q1PMOfOF38VnzMXU3/0mlZQ8B+LFDB7q3iSby/EQ4k4tzdYZRA8jnno8HEQ/QoSMyOhJnB2cAulboSu1CtXml6Cv6a+R2y82+PvtYBmxJGIxbbqP3lNykMcamsk2uvX0iSZ/WTZ0hz5w2fJt3zBQii5ECgMj2LNXhLyY2hosPL3Iz7Caufg2eZ2rb/geH5vJXneFQawjOT58ydPznfOm6jF+LwSOfvPT+fhZr3nwTdk6AsCBw8dZfP49bHo71O4Z/Dn995g/QokSLNN+TuZlqcs0iaZkhz9SmFunxL4RlSQFAZHup6Um+LWgbWy5toU6ROrz60qsA3I+4T8nvS6JDx4LPnoJ93CrwsdEQfhseXmJIYCB9evak1H//8aQ52BWvgtPhtZTwjZvDv94nUO8T/fX3Aed0OgLyV8DTCveUmkzVlPZ2cz9Ta5xTCJEyKQCILCMt0/ZOAl6PiWJf6HVK2DnwundhAMIiw3h15atcDbnK+YHncYrL1Ddf2syEXRMYUH2AvgBwyS0vXu75yOuej/wRD8DDRzt5lb44FWvNqJmrGD21DrrYWJ74+NDv/dkEtGmjv37ip+DkOryZc08verK2ZqZqjU6UMr5dCMvRKaWUrYNIKDQ0FG9vb0JCQvDySrpIhxDGmJNZRsdGs+L4Ci4/uswn9T7RZ+ojt4xk0u5JDHx5INNbTge08fNuX7nxNPopFwZeoHiu4gD8feFv/jj7B42LNaZd6XbPrx/Xzh8/3G0yUHv3bhb26kXJc3EV7l27wrRpkMtw6FxC+8BgvH28QKyT6WWoNQ+EEKlmTh4qNQAiw0htJqTvyBYbo63p7uHLZDt72gH/nP6FZQdmUs+vIXPqjwbAXmdPv/X9eBr9lK4Vu+onu/HP4Y+zvTPPYp7pz63T6fjlrV/I45aHgl4F9ek5S7SgZokWFCRRR7q4Tn6Tgf1PnjB41Ch8vvsOnVJQoADMmQOtW7/wntK7w5sMoxMi+5ECgMgQzHmCv/zoMkuv7eGxWx7eLN5MyyyVgsm5IDIUPrwIOYsxHlj/5B5c3sYZJw9yxJ1Tp9PRpNw7hOnsOa6zp1jceXtV7kXfqn31S8zGaxXQKsVYDd/V1Pv3X0r27o3XhQtaQo8eMHUq5Mz5ws8CpMObEML6pAlApIo5T+vG9k2YBnHV3UpBdAQ4ugFadfeqvwfz373/mPfaPArHtcs3Ozibzevfh4DX4J3f6YI2exzfl4IHF6DHDihSRzvxgwtwPRDylgHfKgQCa0h923pyVfPx3MLDmfDJJ3w4Y4aWULAgzJsHLVuaeIXnEhc04ofcCSFEcqQJQFhVck/rxjJ6Y/veDj7CkgcXoFgTcM2pPUGfWAm/94HizeDtdRB3rg0XNnDu/jkuPLhAYe/C7AM25y0DReuDTyXg+dSxy3ruBNecYOdAK2A9QK4S2ivOBkwf925MclXzrYDH27ezoHdvil+6pCX26QNffw3e3iacOSnp8CaEsCYpAFhYWp+M00ua29sTmAwEA8viK5PiOsGVu3WUyYcXaL3hXxml35dfOsKD89B9G/g10DJql5za0/+jy/rzBgCf1v2UGBVDyTwlIS5mir4CPbYbxNAU+MA9r0GtwnpMZ2rburEqePfHj1kwYgT5Z84EILJwYZznz4dmzcyIwDhpmxdCWIssBmRBI9Cqh7vF/RxhoX0tLS3XPhH1RFtF7rrhUjbLVreBid5wZQegZfR/h92EA9/D6Z8NT1LwZShcG3i+OlzzovVg4AXou18fYw2ge6Xu9KrciwKeBYCU28ZroNUExGeaxhbOSa4i3tS29cTnbbR1K9fKldNn/rz3Hs4nT1ok8xdCCGuSGgALMWdKVXP2jd/fUjUF5lx7+fHlHA4+TLXKvYjJV44AIDRoG6xqrVW/v3fk+c5REfAszOAJPl++8lBnJOQpZXjiBEvPxhvn5MG4XB5G7zPx/Zs6bj25KvS0jnufBLwVGorX8OEEzIlbiLdoUViwABo3NuNMQghhO1IAsJCUhm3F/4zPhMwZ4mXuZDAvKiyceBauZdIePvr54bl5iLf/fI9iLt5s7fZ8adglx5aw5dIWyF8R8pUDoFdOf9zc8vLELY9+v67AsuZTwc4Bcvjp09/2LoxTkwlJMltF8hmwqfdvatu4sSr0NLetb9pEtT594No1bbt/f5g4ETzNmatPCCFsSwoAFpJcFfJmtKr2eMPRMh9TzmFuTYFBZhl+h6anf+XVmEgG1xys32fuj23h0hZouwQqxkXm4MLl4EM8cslhcL4qpd9kS/6KkLe0Pm1h3jIEDrsDGGagvvnKGc3Ua2A8szUlA37R/aelNiRVx4eEwMcfa0/6AP7+sHAhNGiQhkiEEMI2pABgIcaqpruSdFW0+AzMlGpoozUF0ZHsCb9NDe8i+qSvdn7FqnN/cLLWUCjzppYYfofNf/Vnn0tOgwJARW8/jrvkIDLqiT7t41zFeeXt3/DP4Y9SCl3cZDblqvUzeq/neN7WHi+lp2pjma0pGXCGWv1twwZ49124fl3b/vBD+OorcHdP70iEEMIipABgQYkzwXMYXxb1nJF9E4+Pjw0+zNngw+BbFXwra2/ePQMzyzDWNRcfDb+vP9+lh5c4eT0Q7p4C4goAOfyg5OvU9PZjd2w0l+wcCABmtprJvNfnGTYVOLhAydeTxGnuZDSW7rGeISbDefgQhgyBxYu17RIltKf+evXSMwohhLC4bFMASK8hdy/MBGOjKRLzDBzdqAEUC7/Lx5s+5vOI+5TrtP55rcD+H+DoQuo2+Jxd8QUAr0IAxERHsv1ZONec3AkA+lTpQ/ESLfnUt8rz6zh5wNu/kR+om+Dyw+0dmWRKnNh+9TVbX58//oD33oPgYG2K38GD4YsvwM0tvSIQQgiryRYFAHMmrrGEZzHPCLweyPXQ6wwv3+n5tTcNQxf4Lf/WH0P9uHnpXRxcWHZcqyf4KzIUnONmbipUAx4H0ziHH1/Hx+nsSfFhd5nsmpuGuudD6IYXqskk4BGmN0GYer+2nozGJtd/8EDL7JfFfXoBAbBoEdSunR5XF0KIdGH1eQAmTJiATqdj8ODB1r6UUcl1JIsfA2/KWPh9aBnpPiBWxRq898fZP+j9W29WnlipT4uIiqD+4vp0XtOZzyLDCASWAu86e6FUDFdCruj39XT25Jtm39D/zVVaL/p4Vd+Fzn9RvGJXg/HtF93yMCVB5h9/P/vQMsv4awWiTY5jTHJt64nvNV7C69tCul5/3TooW1bL/O3sYOhQOHpUMn8hRJZj1RqAAwcOMHfuXCpUqGDNy6QoucwupSfjBxEPOHvvLF7OXizNV1YrQERFwOwK2Idc5dHw+3g4eQBw5NYRFh5diE6no1P5TgB4u3hTxbcKOV1yEvYsjBrOntQAWlTrx5gqvfGJXyc+zpBaQ9gHzDQSZ+L27hd1jDOlaj+5NnRzhxxmKffuaR37Vq3StkuV0p76a6Y0878QQmReVqsBePz4MZ07d2bevHnkNHEFNGtIscNYbAzsmgR/9oNn4frMdca+GdReWJtPA6c9zxAdXeHJfWJinvHHo+dP8E2KNeHzBp/TsWxHg1MfevcQW7pt0c9gB5DXPS8FPAskWW0Okp+5LnFmbk7HOFPPCcnXlOwzsm+W8+uv2lP/qlXaU/+IEXDkiGT+QogszWoFgA8++IBWrVrRpEmTFPeLjIwkNDTU4GVJ+kzw+AqYWRY2DKJr/Jt29rB7IhyaA48u6zPRErlKUMS7CJHOiSZ26boJBl3mWYKZ7WoXrs3o+qNpWjy5CnfTJa7CN7bymzmZuqnnhBdPZJQl3b0LHTtC+/Zw5w6UKQN792qT+ri42Do6IYSwKqs0AaxevZrDhw9z4MCBF+47YcIExo0bZ40w9CYBTrFRfHH3NC97FmQp4EvcE2+1/qCz431nL30m2rlCZzpX6Mw+YGPCExWoBkCiiW0typQqfHM7xqWlWSBLrj+vFPz8M3zwgVb1b28PI0fC6NHg7Gzr6IQQIl3olIpfws0yrl27RrVq1di0aRMVK1YEoEGDBlSqVIlp06Yl2T8yMpLIyEj9dmhoKIULFzZpLWNz3Ay7yem7pymRqwR+cdPVmjIKIHG7+Aiy7prs2eJeb9/WMv5ff9W2y5fX2vqrVrVtXEIIYQGhoaF4e3ublIdavACwbt063njjDezt7fVpMTEx6HQ67OzsiIyMNHgvMXOCTy+2XLY3vWXZe1UKVq+GgQPh/n1wcIBPP4VRo8DJydbRCSGERZiTh1q8CaBx48acOHHCIK1nz56UKlWKESNGpJj5ZwTGMkBLz3CXkWXJew0Ohvffh99+07YrVtRm9qtUyZZRCSGETVm8AODp6Um5cuUM0tzd3cmdO3eS9IzG0ivvCRtTCpYvh0GDtCl9HR3hs8/gk0+0fwshRDZm9YmAMgtzh8GNwPSJhIQN3LwJr78O3bppmX+VKnDwIPzvf5L5CyEE6TQV8Pbt29PjMmlizspz5i7TK9KRUrBkCXz0ETx6pGX2Y8fCsGGS8QshRALZYi0AU5gzDC5DLVMrnrt+XVuyd8MGbbtaNa2HfwZvehJCCFuQJoA45kywk63GzGcGSsGCBdpsfhs2aL36J07UJvWRzF8IIYySGoAETJ1gx+bL1Irnrl6Fvn1h0yZtu0YN7am/dGnbxiWEEBmcFAASMXUYnK2Xyc32lIK5c7W2/bAwbere8eO1tv8MPtRUCCEyAikApEGWHDOfGVy+DH36wNat2nbt2rBwIZQsadOwhBAiM5E+ACLziI2FmTO1dv2tW8HVFb79Fv79VzJ/IYQwk9QAiMzh0iXo3Rvih5TWq6d1/HvpJZuGJYQQmZXUAIiMLTYWZszQFu3Zvh3c3GD6dO3fkvkLIUSqSQ2AyLguXIBevWDnTm27QQOYPx+KF7dpWEIIkRVIDYDIeGJitLb9ChW0zN/dHX74QWv3l8xfCCEsQmoARMZy9qz21L9nj7bdqJH21O/vb9u4hBAii5EaAJExxMTA119rS/Tu2QMeHjBnDmzZIpm/EEJYgdQACNs7c0Z76g8M1LabNoV586BoUdvGJYQQWZjUAAjbiY6GSZOgcmUt8/fy0qr7N26UzF8IIaxMagCEbZw6BT17woED2nbLllqVf+HCto1LCCGyCakBEOkrKgq+/BKqVNEyf29vbfGe9esl8xdCiHQkNQAi/Rw/rj31Hz6sbbduDbNnQ8GCto1LCCGyIakBENYXFQWffw7VqmmZf86csGwZ/P67ZP5CCGEjUgMgrOvoUe2p/+hRbbtNG5g1C3x9bRmVEEJke1IDIKzj2TMYMwaqV9cy/1y5YOVKWLtWMn8hhMgApAZAWN7hw9CjB5w4oW23a6ct45s/v03DEkII8ZzUAAjLiYyEzz6Dl1/WMv88eeDHH+GXXyTzF0KIDEZqAIRlHDigtfWfOqVtd+gA338PefPaNi4hhBBGSQ2ASJunT2HkSKhZU8v88+XTnvh//FEyfyGEyMCkBkCkXmCg9tT/33/a9jvvwPTpWtW/EEKIDE1qAIT5IiJg2DCoU0fL/PPn13r3r1wpmb8QQmQSUgMgzLNnj/bUf+6ctt2lC3z3nTbMTwghRKYhNQDCNE+ewJAhULeulvn7+moz+S1bJpm/EEJkQlIDIF5s507o1QsuXNC2e/SAqVO1KX2FEEJkSlIDIJIXHg4ffgj162uZf8GC8Ndf2up9kvkLIUSmJjUAwrjt26F3b7h0Sdvu3Ru++UZbvlcIIUSmJzUAwtDjx/DBB9CwoZb5Fy4Mf/8N8+dL5i+EEFmI1ACI57ZuhT594PJlbfvdd2HKFPDysmlYQgghLM/iNQATJkygevXqeHp6ki9fPtq2bcvZs2ctfRlhSaGh0K8fNGmiZf5Fi8LmzTBnjmT+QgiRRVm8ALBjxw4++OADAgMD2bx5M9HR0TRr1ozw8HBLX0pYwqZNUK6cltkD9O+vLeTTpIlt4xJCCGFVOqWUsuYF7t69S758+dixYwevvPLKC/cPDQ3F29ubkJAQvOTp03pCQuDjj2HBAm3b31/7d8OGto1LCCFEqpmTh1q9E2BISAgAuWSymIxjwwbtqT8+8x84EI4fl8xfCCGyEat2AlRKMWTIEOrWrUu5cuWM7hMZGUlkZKR+OzQ01JohZW8PH2qz+S1erG0XLw4LF4IJNTNCCCGyFqvWAAwYMIDjx4+zatWqZPeZMGEC3t7e+lfhwoWtGVL29eef2lP/4sWg08HgwdpTv2T+QgiRLVmtD8DAgQNZt24d//77L/7+/snuZ6wGoHDhwtIHwFIePNAy+2XLtO2XXtJm8qtTx6ZhCSGEsDxz+gBYvAlAKcXAgQNZu3Yt27dvTzHzB3B2dsbZ2dnSYQiA337ThvfdugV2dlr1/+efg6urrSMTQghhYxYvAHzwwQesXLmS3377DU9PT27dugWAt7c3rpLxpI9797Q5/OObXkqV0p76a9a0bVxCCCEyDIs3Aeh0OqPpixYtokePHi88XoYBptGaNfD++3DnjvbUP2wYjB0LLi62jkwIIYSV2bwJQNjA3bswYAD89JO2XaaM9tT/8su2jUsIIUSGJIsBZQU//6xl+D/9BPb28OmncPiwZP5CCCGSJYsBZWa3b2sr9/36q7YdP8yvalWbhiWEECLjkxqAzEgprYNf2bJa5u/gAP/7Hxw6JJm/EEIIk0gNQGZz65bWyW/dOm27YkWtrb9yZZuGJYQQInORGoDMQilYvlxr61+3TnvqHzcO9u+XzF8IIYTZpAYgM7h5E957T5vOF7QMf9Ei7elfCCGESAWpAcjIlIIlS7S2/j//BEdH+OIL2LdPMn8hhBBpIjUAGdX16/Duu9rSvQDVqmlP/cmsqiiEEEKYQ2oAMhqlYMEC7al/wwZwcoIJE2DvXsn8hRBCWIzUAGQkV69C376waZO2XaMGLFyodfwTQgghLEhqADICpWDuXO0Jf9MmcHaGKVNg927J/IUQQliF1ADY2uXL0KcPbN2qbdeqpT31lypl07CEEEJkbVIDYCuxsTBrlvbUv3Wrtlrf1Kmwc6dk/kIIIaxOagBs4dIl6N0btm/XtuvW1Z76X3rJpmEJIYTIPqQGID3FxsKMGVC+vJb5u7nBd9/Bjh2S+QshhEhXUgOQXi5c0J76//1X265fXxvuV7y4beMSQgiRLUkNgLXFxMC0aVChgpb5u7vDDz/AP/9I5i+EEMJmpAbAms6ehV69YM8ebbtRI5g/H/z9bRuXEEKIbE9qAKwhJga++QYqVdIyfw8PmD0btmyRzF8IIUSGIDUAlnbmjPbUHxiobTdtCvPmQdGito1LCCGESEBqACwlOhomTdKW6g0MBE9PLePfuFEyfyGEEBmO1ABYwqlT0LMnHDigbbdooU3tW7iwbeMSQgghkiE1AGkRHQ1ffQVVqmiZv7e3tmTvX39J5i+EECJDkxqA1Dp+XHvqP3xY227VCubMgYIFbRuXEEIIYQKpATBXVBSMHw/VqmmZf44csHQp/PGHZP5CCCEyDakBMMfRo9pT/9Gj2vbrr2vD+3x9bRmVEEIIYTapATDFs2cwZgxUr65l/rlywYoVsG6dZP5CCCEyJakBeJHDh7Wn/uPHte127bSpfH18bBuXEEIIkQZSA5CcyEj47DN4+WUt88+TB378EX75RTJ/IYQQmZ7UABhz4ID21H/qlLb91lvw/feQL59t4xJCCCEsRGoAEnr6FD75BGrW1DL/vHnh55/hp58k8xdCCJGlSA1AvMBAbQ7/M2e07bffhhkztKp/IYQQIouRGoCICBg2DOrU0TL//PlhzRpYtUoyfyGEEFlW9q4B2LNHa+s/d07b7tIFpk2D3LltGpYQQghhbVarAZg5cyb+/v64uLhQtWpVdu7caa1Lme/JExgyBOrW1TJ/X1/4/XdYtkwyfyGEENmCVQoAP/74I4MHD2bUqFEcOXKEevXq0bJlS65evWqNy5ln506oWBG+/RaUgu7dtQ5/r71m68iEEEKIdKNTSilLn7RGjRpUqVKFWbNm6dNKly5N27ZtmTBhQorHhoaG4u3tTUhICF5eXpYLKjwcPv1U69inlDZv/9y58OqrlruGEEIIYUPm5KEWrwF49uwZhw4dolmzZgbpzZo1Y8+ePUn2j4yMJDQ01OBlcTt2QIUKMH26lvn36gUnT0rmL4QQItuyeAHg3r17xMTEkD9/foP0/Pnzc+vWrST7T5gwAW9vb/2rcOHClg4Jtm+HS5egUCH4+29YsEBbxU8IIYTIpqzWCVCn0xlsK6WSpAF88sknhISE6F/Xrl2zfDCffALjxmlt/c2bW/78QgghRCZj8WGAefLkwd7ePsnT/p07d5LUCgA4Ozvj7Oxs6TAMOTnB//5n3WsIIYQQmYjFawCcnJyoWrUqmzdvNkjfvHkztWvXtvTlhBBCCJEKVpkIaMiQIXTt2pVq1apRq1Yt5s6dy9WrV+nXr581LieEEEIIM1mlANCxY0fu37/P559/TnBwMOXKleOvv/6iaNGi1ricEEIIIcxklXkA0sJq8wAIIYQQWZxN5wEQQgghRMYnBQAhhBAiG5ICgBBCCJENSQFACCGEyIakACCEEEJkQ1IAEEIIIbIhq8wDkBbxoxKtsiqgEEIIkYXF552mjPDPcAWAsLAwAOusCiiEEEJkA2FhYXh7e6e4T4abCCg2NpabN2/i6elpdPXA1AoNDaVw4cJcu3YtS0wwlNXuB+SeMgu5p8whq91TVrsfsM49KaUICwujQIEC2Nml3Mqf4WoA7OzsKFSokNXO7+XllWW+PJD17gfknjILuafMIavdU1a7H7D8Pb3oyT+edAIUQgghsiEpAAghhBDZULYpADg7OzNmzBicnZ1tHYpFZLX7AbmnzELuKXPIaveU1e4HbH9PGa4ToBBCCCGsL9vUAAghhBDiOSkACCGEENmQFACEEEKIbEgKAEIIIUQ2lGUKADNnzsTf3x8XFxeqVq3Kzp07U9x/x44dVK1aFRcXF4oVK8bs2bPTKVLTmXNPwcHBdOrUiZIlS2JnZ8fgwYPTL1AzmHNPa9asoWnTpuTNmxcvLy9q1arFxo0b0zFa05hzT7t27aJOnTrkzp0bV1dXSpUqxbfffpuO0ZrG3P9P8Xbv3o2DgwOVKlWyboCpYM49bd++HZ1Ol+T133//pWPEKTP3dxQZGcmoUaMoWrQozs7OFC9enIULF6ZTtKYx55569Ohh9HdUtmzZdIz4xcz9Pa1YsYKKFSvi5uaGr68vPXv25P79+9YJTmUBq1evVo6OjmrevHnq9OnTatCgQcrd3V1duXLF6P6XLl1Sbm5uatCgQer06dNq3rx5ytHRUf3yyy/pHHnyzL2noKAg9eGHH6olS5aoSpUqqUGDBqVvwCYw954GDRqkJk2apPbv36/OnTunPvnkE+Xo6KgOHz6czpEnz9x7Onz4sFq5cqU6efKkCgoKUsuWLVNubm5qzpw56Rx58sy9p3iPHj1SxYoVU82aNVMVK1ZMn2BNZO49bdu2TQHq7NmzKjg4WP+Kjo5O58iNS83v6PXXX1c1atRQmzdvVkFBQWrfvn1q9+7d6Rh1ysy9p0ePHhn8bq5du6Zy5cqlxowZk76Bp8Dce9q5c6eys7NT3333nbp06ZLauXOnKlu2rGrbtq1V4ssSBYCXX35Z9evXzyCtVKlSauTIkUb3Hz58uCpVqpRB2nvvvadq1qxptRjNZe49JVS/fv0MWQBIyz3FK1OmjBo3bpylQ0s1S9zTG2+8obp06WLp0FIttffUsWNH9dlnn6kxY8ZkuAKAufcUXwB4+PBhOkRnPnPvZ8OGDcrb21vdv38/PcJLlbT+X1q7dq3S6XTq8uXL1ggvVcy9pylTpqhixYoZpE2fPl0VKlTIKvFl+iaAZ8+ecejQIZo1a2aQ3qxZM/bs2WP0mL179ybZv3nz5hw8eJCoqCirxWqq1NxTRmeJe4qNjSUsLIxcuXJZI0SzWeKejhw5wp49e6hfv741QjRbau9p0aJFXLx4kTFjxlg7RLOl5fdUuXJlfH19ady4Mdu2bbNmmCZLzf38/vvvVKtWjcmTJ1OwYEECAgIYOnQoERER6RHyC1ni/9KCBQto0qQJRYsWtUaIZkvNPdWuXZvr16/z119/oZTi9u3b/PLLL7Rq1coqMWa4xYDMde/ePWJiYsifP79Bev78+bl165bRY27dumV0/+joaO7du4evr6/V4jVFau4po7PEPX3zzTeEh4fToUMHa4RotrTcU6FChbh79y7R0dGMHTuWPn36WDNUk6Xmns6fP8/IkSPZuXMnDg4Z709Kau7J19eXuXPnUrVqVSIjI1m2bBmNGzdm+/btvPLKK+kRdrJScz+XLl1i165duLi4sHbtWu7du0f//v158OBBhugHkNa/D8HBwWzYsIGVK1daK0SzpeaeateuzYoVK+jYsSNPnz4lOjqa119/nRkzZlglxoz3vzWVEi8drJRKcTlhY/sbS7clc+8pM0jtPa1atYqxY8fy22+/kS9fPmuFlyqpuaedO3fy+PFjAgMDGTlyJCVKlOCdd96xZphmMfWeYmJi6NSpE+PGjSMgICC9wksVc35PJUuWpGTJkvrtWrVqce3aNb7++mubFwDimXM/sbGx6HQ6VqxYoV8pburUqbRv354ffvgBV1dXq8dritT+fVi8eDE5cuSgbdu2Voos9cy5p9OnT/Phhx/yv//9j+bNmxMcHMywYcPo168fCxYssHhsmb4AkCdPHuzt7ZOUqO7cuZOk5BXPx8fH6P4ODg7kzp3barGaKjX3lNGl5Z5+/PFHevfuzc8//0yTJk2sGaZZ0nJP/v7+AJQvX57bt28zduzYDFEAMPeewsLCOHjwIEeOHGHAgAGAltkopXBwcGDTpk00atQoXWJPjqX+P9WsWZPly5dbOjyzpeZ+fH19KViwoMEysaVLl0YpxfXr13nppZesGvOLpOV3pJRi4cKFdO3aFScnJ2uGaZbU3NOECROoU6cOw4YNA6BChQq4u7tTr149vvjiC4vXTmf6PgBOTk5UrVqVzZs3G6Rv3ryZ2rVrGz2mVq1aSfbftGkT1apVw9HR0Wqxmio195TRpfaeVq1aRY8ePVi5cqXV2sFSy1K/J6UUkZGRlg4vVcy9Jy8vL06cOMHRo0f1r379+lGyZEmOHj1KjRo10iv0ZFnq93TkyBGbNw9C6u6nTp063Lx5k8ePH+vTzp07h52dHYUKFbJqvKZIy+9ox44dXLhwgd69e1szRLOl5p6ePHmCnZ1htmxvbw88r6W2KKt0LUxn8UMtFixYoE6fPq0GDx6s3N3d9b1BR44cqbp27arfP34Y4EcffaROnz6tFixYkGGHAZp6T0opdeTIEXXkyBFVtWpV1alTJ3XkyBF16tQpW4RvlLn3tHLlSuXg4KB++OEHg+E+jx49stUtJGHuPX3//ffq999/V+fOnVPnzp1TCxcuVF5eXmrUqFG2uoUkUvPdSygjjgIw956+/fZbtXbtWnXu3Dl18uRJNXLkSAWoX3/91Va3YMDc+wkLC1OFChVS7du3V6dOnVI7duxQL730kurTp4+tbiGJ1H7vunTpomrUqJHe4ZrE3HtatGiRcnBwUDNnzlQXL15Uu3btUtWqVVMvv/yyVeLLEgUApZT64YcfVNGiRZWTk5OqUqWK2rFjh/697t27q/r16xvsv337dlW5cmXl5OSk/Pz81KxZs9I54hcz956AJK+iRYumb9AvYM491a9f3+g9de/ePf0DT4E59zR9+nRVtmxZ5ebmpry8vFTlypXVzJkzVUxMjA0iT565372EMmIBQCnz7mnSpEmqePHiysXFReXMmVPVrVtXrV+/3gZRJ8/c39GZM2dUkyZNlKurqypUqJAaMmSIevLkSTpHnTJz7+nRo0fK1dVVzZ07N50jNZ259zR9+nRVpkwZ5erqqnx9fVXnzp3V9evXrRKbLAcshBBCZEOZvg+AEEIIIcwnBQAhhBAiG5ICgBBCCJENSQFACCGEyIakACCEEEJkQ1IAEEIIIbIhKQAIIYQQ2ZAUAIQQQohsSAoAQgghRDYkBQAhhBAiG5ICgBBCCJENSQFACCGEyIb+D09A5MSr6wWsAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 600x400 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig, ax = plt.subplots(1, 1, figsize=(6, 4))\n",
    "# scaling\n",
    "#Data,Data2 = 40*Data, 40*Data2\n",
    "ax.scatter(Data2_L1_L2[:, 0], Data2_L1_L2[:, 1], s=10, c=\"cyan\",label=\"Data+Noise\")\n",
    "comp_vec = reducer_L1_L2.components_[0]\n",
    "# Get the PCA axis and the data xrange to be the same\n",
    "scaler = bd/comp_vec[0]\n",
    "comp_vec = scaler * comp_vec\n",
    "\n",
    "xhat,yhat = comp_vec[0], comp_vec[1]\n",
    "ax.plot(np.array([0,xhat]),np.array([0,yhat]),c=\"r\",label=\"PCA comp.\")\n",
    "ax.plot(Data_L1_L2[:80,0],Data_L1_L2[:80,1],c=\"green\",linestyle=\"dotted\",label=\"Data L1 L2\")\n",
    "ax.plot(Data_L1_L2[80:,0],Data_L1_L2[80:,1],c=\"green\",linestyle=\"dotted\")\n",
    "ax.set_title(\"PCA Component Hard Data\")\n",
    "ax.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If there is no single linear trend PCA will still find the direction that maximizes the\n",
    "explained variance, but that direction won't uncover a useful generalization.  Sometimes\n",
    "PCA just has nothing useful to tell us."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And in fact the variance accounted for can look quite good with a very bad model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.99032184])"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reducer_L1_L2.explained_variance_ratio_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here are two important requirements for PCA to give good results as a dimensionality reduction technique:\n",
    "\n",
    "1.  The relationship between the variables is linear or nearly so as in our noise example. This is what's going wrong in the picture above. There's no single linear relationship that capture all the points.\n",
    "2.  The variables can't be completely independent. you need to have correlations between the variables to be reduced to a smaller number of components."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Question 2 (Completely optional):**  We've been measuring information loss (or how good an approximation PCA and SVD\n",
    "give) using Frobenius Norm, so the Eckart-Young theorem should apply.  SVD Reduced should give the best rank 2 \n",
    "approximation.  Yet here are the results for our two reductions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3.899313318962578"
      ]
     },
     "execution_count": 39,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#PCA\n",
    "\n",
    "X = iris.data\n",
    "reducer = dec.PCA(n_components=2)\n",
    "reducer_svd = dec.TruncatedSVD(n_components=2)\n",
    "X_reduced = reducer.fit_transform(X)\n",
    "X_reduced_svd = reducer_svd.fit_transform(X)\n",
    "information_lost(X, X_reduced, reducer)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3.940889887879374"
      ]
     },
     "execution_count": 40,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "information_lost(X, X_reduced_svd, reducer_svd)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "PCA wins. Less information lost.  How is this possible?  Have we just shaken the foundations of Linear Algebra\n",
    "by discovering a counterexample: a better approximation than the reduced SVD approximation?\n",
    "(*Note:  This question is best answered by looking at the definition of `information_list` and knowing a little Linear Algebra.*)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To measure the information lost we untransform the PCA and SVD reductions\n",
    "and compare the untransformed data to the original data. The untransformed SVD data has rank 2.\n",
    "The untransformed PCA data does not."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "SVD untransformed: Rank 2\n",
      "PCA untransformed: Rank 3\n"
     ]
    }
   ],
   "source": [
    "from numpy.linalg import matrix_rank\n",
    "\n",
    "print(\"SVD untransformed: Rank\", matrix_rank(reducer_svd.inverse_transform(X_reduced_svd)))\n",
    "\n",
    "print(\"PCA untransformed: Rank\", matrix_rank(reducer.inverse_transform(X_reduced)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So the truncated SVD estimate **is** the best rank 2 approximation, but the PCA\n",
    "approximation is a rank 3 approximation, so it can be better.\n",
    "\n",
    "The reason this is possible is instructive.\n",
    "The untransformed SVD representation of the 150 rows of X is just \n",
    "150 weighted sums of the same 2 orthogonal\n",
    "eigenvectors, so it must have rank 2.  The untransformed PCA representation\n",
    "is computed in two steps:\n",
    "\n",
    "1. Weighted sums of the leading 2 eigenvectors of the covariance matrix, yielding a matrix M which is an \n",
    "   approximation of the **centered data**,  which must have rank 2. \n",
    "2. We add the means of the 4 iris variables to M,  uncentering M.  The result of this computation does\n",
    "   not have to have rank 2.\n",
    "  \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.6"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {
    "height": "171px",
    "width": "253px"
   },
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": "block",
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
